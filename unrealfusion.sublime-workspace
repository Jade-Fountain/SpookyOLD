{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"C",
				"Context"
			],
			[
				"point",
				"point_color"
			],
			[
				"count",
				"count_it"
			],
			[
				"clears",
				"clears_remaining"
			],
			[
				"clear",
				"clear_count"
			],
			[
				"Nod",
				"NodeDescriptor"
			],
			[
				"filtered",
				"filtered_relevance"
			],
			[
				"m1",
				"m1_chunked"
			],
			[
				"current",
				"currentNode"
			],
			[
				"Calibration",
				"CalibrationResult"
			],
			[
				"curre",
				"currentCalibration"
			],
			[
				"cur",
				"currentCalibration"
			],
			[
				"is",
				"is_open"
			],
			[
				"artic",
				"articulationType"
			],
			[
				"target",
				"target_out"
			],
			[
				"Matrix",
				"Matrix3f"
			],
			[
				"combined",
				"combinedD"
			],
			[
				"combin",
				"combinedF"
			],
			[
				"Matr",
				"MatrixXf"
			],
			[
				"com",
				"combinedD"
			],
			[
				"Vect",
				"VectorXf"
			],
			[
				"matr",
				"MatrixXf"
			],
			[
				"Vecto",
				"VectorXf"
			],
			[
				"Vector",
				"Vector3f"
			],
			[
				"Matri",
				"MatrixXf"
			],
			[
				"vector",
				"VectorXf"
			],
			[
				"Mat",
				"MatrixXf"
			],
			[
				"times",
				"timestamps"
			],
			[
				"jso",
				"json_data"
			],
			[
				"opt",
				"optitrack_data"
			],
			[
				"OP",
				"optitrack_data"
			],
			[
				"optit",
				"optitrack_data_raw"
			],
			[
				"opti",
				"optitrack_data_raw"
			],
			[
				"op",
				"optitrack_data_raw"
			],
			[
				"lower",
				"lower_i"
			],
			[
				"upper",
				"upper_i"
			],
			[
				"file",
				"file_name"
			],
			[
				"inliers",
				"inliers_needed"
			],
			[
				"max",
				"max_models"
			],
			[
				"draw",
				"drawSphere"
			],
			[
				"center",
				"centerError"
			],
			[
				"unambiguous",
				"unambiguous_measurements"
			],
			[
				"ambiguous",
				"ambiguous_measurements"
			],
			[
				"addMeas",
				"addMeasurementGroup"
			],
			[
				"measurement",
				"measurement_buffer"
			],
			[
				"parent",
				"parent_desc"
			],
			[
				"Bound",
				"BoundingBox"
			],
			[
				"bound",
				"bounding_box"
			],
			[
				"image",
				"image_file_path"
			],
			[
				"proj",
				"proj_co"
			],
			[
				"vert",
				"vert_array"
			],
			[
				"Touch",
				"TouchStates"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "Searching 10 files for \"FUSION_LOG\" (case sensitive)\n\nC:\\Users\\NUbots\\Documents\\Unreal Projects\\UnrealFusion\\Source\\UnrealFusion\\easywsclient.cpp:\n  220                  closesocket(sockfd);\n  221                  readyState = CLOSED;\n  222:                 FUSION_LOG(ret < 0 ? \"Connection error!\\n\" : \"Connection closed!\\n\");\n  223                  break;\n  224              } \n  ...\n  236                  closesocket(sockfd);\n  237                  readyState = CLOSED;\n  238:                 FUSION_LOG(ret < 0 ? \"Connection error!\\n\" : \"Connection closed!\\n\");\n  239                  break;\n  240              }\n\nC:\\Users\\NUbots\\Documents\\Unreal Projects\\UnrealFusion\\Source\\UnrealFusion\\Websocket.cpp:\n   23  \n   24  void UWebsocket::handle_message(const std::string& message){\n   25: \tFUSION_LOG(message);\n   26  }\n   27  // Called when the game starts\n   ..\n   35  \trc = WSAStartup(MAKEWORD(2, 2), &wsaData);\n   36  \tif (rc) {\n   37: \t\tFUSION_LOG(\"WSAStartup Failed.\");\n   38  \t\treturn;\n   39  \t}\n   ..\n   42  \n   43  \tif (ws) {\n   44: \t\tFUSION_LOG(\"Connection successful \" + std::to_string(ws->getReadyState()));\n   45  \t}\n   46  \telse {\n   47: \t\tFUSION_LOG(\"Connection unsuccessful \");\n   48  \t}\n   49  \n   ..\n   67  \t\tws->poll(1000);\n   68  \t\tws->dispatch([this](const std::string & message) {\n   69: \t\t\tFUSION_LOG(message);\n   70  \t\t\tlatestString = message;\n   71  \t\t});\n\n7 matches across 2 files\n",
			"settings":
			{
				"buffer_size": 1410,
				"line_ending": "Windows",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"contents": "/*  This file is part of UnrealFusion, a sensor fusion plugin for VR in the Unreal Engine\n    Copyright (C) 2017 Jake Fountain\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"Spooky.h\"\n#include \"SpookyFusionPlant.h\"\n#include \"Spooky/Utilities/TimeProfiling.h\"\n#include <iostream>\n\n\nusing spooky::Measurement;\n//===========================\n//Setup and initialisation\n//===========================\n\n\n// Sets default values for this component's properties\nUSpookyFusionPlant::USpookyFusionPlant()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = true;\n\t// ...\n}\n\n\n// Called when the game starts\nvoid USpookyFusionPlant::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// ...\n\t\n}\n\n\n// Called every frame\nvoid USpookyFusionPlant::TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction )\n{\n\tSuper::TickComponent( DeltaTime, TickType, ThisTickFunction );\n}\n\n\nUFUNCTION(BlueprintCallable, Category = \"Spooky\") void USpookyFusionPlant::Configure(float input_units_m, float output_units_m)\n{\n\tplant.config.units.input_m = input_units_m;\n\tplant.config.units.output_m = output_units_m;\n\t/*\n\tplant.config.correlator.ambiguous_threshold = correlator_ambiguous_threshold;\n\tplant.config.correlator.elimination_threshold = correlator_elimination_threshold;\n\tplant.config.correlator.diff_threshold = correlator_diff_threshold;\n\n\tplant.config.calibrator.diff_threshold = calibration_diff_threshold;\n\tplant.config.calibrator.min_count_per_node = calibration_min_count_per_node;\n\tplant.config.calibrator.count_threshold = \n\t\t{\t\n\t\t\t{spooky::CalibrationResult::State::UNCALIBRATED,100},\n\t\t\t{spooky::CalibrationResult::State::REFINING,100 },\n\t\t\t{spooky::CalibrationResult::State::CALIBRATED,100}\n\t\t};\n\tplant.config.calibrator.initial_quality_threshold = calibration_initial_quality_threshold;\n\tplant.config.calibrator.quality_convergence_threshold = calibration_quality_convergence_threshold;\n\tplant.config.calibrator.fault_hysteresis_rate = calibration_fault_hysteresis_rate;\n\tplant.config.calibrator.relevance_decay_rate = calibration_relevance_decay_rate;\n\tplant.config.calibrator.settle_threshold = calibration_settle_threshold;\n\tplant.config.calibrator.fault_angle_threshold = calibration_fault_angle_threshold;\n\tplant.config.calibrator.fault_distance_threshold = calibration_fault_distance_threshold;*/\n}\n\nUFUNCTION(BlueprintCallable, Category = \"Spooky\") void USpookyFusionPlant::AddSkeleton(USkeletalMeshComponent* skeletal_mesh, FVector position_var, FVector4 quaternion_var)\n{\n\t//TODO: enable complete skeleton fusion\n\t//Add skeleton reference\n\tskeletons.push_back(skeletal_mesh);\n\n\t//Store uncertainties for later\n\tEigen::Vector3f vv(&position_var[0]);\n\tEigen::Vector4f vq(&quaternion_var[0]);\n\tEigen::Matrix<float, 7, 1> uncertainty;\n\tuncertainty << vv, vq;\n\tskeletonCovariances.push_back(uncertainty);\n\treturn;\n}\n\n\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nvoid USpookyFusionPlant::AddOutputTarget(USkeletalMeshComponent * skeletal_mesh)\n{\n\tskeletal_mesh = skeletal_mesh;\n\tTArray<FMeshBoneInfo> boneInfo = skeletal_mesh->SkeletalMesh->RefSkeleton.GetRefBoneInfo();\n\tfor (int i = 0; i < boneInfo.Num(); i++) {\n\t\tFMeshBoneInfo& bone = boneInfo[i];\n\t\t//TODO: make more efficient\n\t\tFTransform b = FTransform(skeletal_mesh->SkeletalMesh->GetRefPoseMatrix(i));\n\t\t//Scale to spooky units\n\t\tb.SetTranslation(b.GetTranslation() * plant.config.units.input_m);\n\t\tspooky::Transform3D bonePoseLocal = convert(b.ToMatrixNoScale());\n\t\t//Set parent\n\t\tspooky::NodeDescriptor parent_desc = (bone.ParentIndex >= 0) ?\n\t\t\tspooky::NodeDescriptor(TCHAR_TO_UTF8(*(boneInfo[bone.ParentIndex].Name.GetPlainNameString()))) :\n\t\t\tspooky::NodeDescriptor();\n\t\t//Set bone name\n\t\tspooky::NodeDescriptor bone_desc = spooky::NodeDescriptor(TCHAR_TO_UTF8(*(bone.Name.GetPlainNameString())));\n\t\t//TODO: find better way to do this check for pose nodes\n\t\tif (bone.Name.GetPlainNameString() == \"pelvis\") {\n\t\t\tplant.addPoseNode(bone_desc, parent_desc, bonePoseLocal);\n\t\t}\n\t\telse {\n\t\t\tplant.addBoneNode(bone_desc, parent_desc, bonePoseLocal);\n\t\t}\n\t\tSPOOKY_LOG(\"Adding Bone: \" + bone_desc.name + \", parent = \" + parent_desc.name);\n\t}\n}\n\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nvoid USpookyFusionPlant::FinaliseSetup() {\n\tplant.finaliseSetup();\n}\n\n//Set the reference frame for the skeleton\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nvoid USpookyFusionPlant::SetReferenceFrame(FString system_name) {\n\tplant.setReferenceSystem(spooky::SystemDescriptor(TCHAR_TO_UTF8(*system_name)));\n}\n\n//===========================\n//Update functions\n//===========================\n\n\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nvoid USpookyFusionPlant::AddPositionMeasurement(TArray<FString> nodeNames, FString systemName, int sensorID, float timestamp_sec, FVector measurement, FVector covariance, bool globalSpace, float confidence)\n{\n\tMeasurement::Ptr m = CreatePositionMeasurement(systemName, sensorID, timestamp_sec, measurement, covariance, confidence);\n\tm->globalSpace = globalSpace;\n\tplant.addMeasurement(m, convertToNodeDescriptors(nodeNames));\n}\n\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nvoid USpookyFusionPlant::AddRotationMeasurement(TArray<FString> nodeNames, FString systemName, int sensorID, float timestamp_sec, FRotator measurement, FVector4 covariance, bool globalSpace, float confidence)\n{\n\tMeasurement::Ptr m = CreateRotationMeasurement(systemName,sensorID,timestamp_sec, measurement.Quaternion(),covariance,confidence);\n\tm->globalSpace = globalSpace;\n\tplant.addMeasurement(m, convertToNodeDescriptors(nodeNames));\n}\n\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nvoid USpookyFusionPlant::AddPoseMeasurement(TArray<FString> nodeNames, FString systemName, int sensorID, float timestamp_sec, FTransform measurement, FVector position_var, FVector4 quaternion_var, bool globalSpace, float confidence)\n{\n\tEigen::Vector3f vv(&position_var[0]);\n\tEigen::Vector4f vq(&quaternion_var[0]);\n\tEigen::Matrix<float, 7, 1> uncertainty;\n\tuncertainty << vv, vq;\n\tMeasurement::Ptr m = CreatePoseMeasurement(systemName, sensorID, timestamp_sec, measurement.GetTranslation(), measurement.GetRotation(), uncertainty, confidence);\n\tm->globalSpace = globalSpace;\n\tplant.addMeasurement(m, convertToNodeDescriptors(nodeNames));\n}\n\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nvoid USpookyFusionPlant::addSkeletonMeasurement(int skel_index) {\n\t//For each bone\n\tauto& skeleton = skeletons[skel_index];\n\tTArray<FMeshBoneInfo> boneInfo = skeleton->SkeletalMesh->RefSkeleton.GetRefBoneInfo();\n\tfor (int i = 0; i < boneInfo.Num(); i++) {\n\t\tFMeshBoneInfo& bone = boneInfo[i];\n\t\tspooky::NodeDescriptor bone_name = spooky::NodeDescriptor(TCHAR_TO_UTF8(*(bone.Name.GetPlainNameString())));\n\t\tFTransform measurement = skeleton->BoneSpaceTransforms[i];\n\t\t//TODO: support confidences\n\t\t//TODO: doesnt seem like the best way to do this!\n\t\t//TODO: support skeleton group measurement input properly: need skeleton->getUncertianty(i), get confidence, time stamp, etc\n\t\tfloat timestamp_sec = 0;// skeleton->getLatestMeasurementTime();\n\t\tMeasurement::Ptr m = CreatePoseMeasurement(skeleton->GetName(), i, timestamp_sec, measurement.GetTranslation(), measurement.GetRotation(), skeletonCovariances[skel_index], 1);\n\t\tm->globalSpace = false;\n\t\tplant.addMeasurement(m, bone_name);\n\t}\n}\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nvoid USpookyFusionPlant::Fuse()\n{\n\tspooky::utility::profiler.startTimer(\"AAA FUSION TIME\");\n\tfor (int i = 0; i < skeletons.size(); i++) {\n\t\taddSkeletonMeasurement(i);\n\t}\n\tplant.fuse();\n\tspooky::utility::profiler.endTimer(\"AAA FUSION TIME\");\n\t//SPOOKY_LOG(spooky::utility::profiler.getReport());\n}\n\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nFTransform USpookyFusionPlant::getBoneTransform(const FString& name) {\n\tspooky::NodeDescriptor bone_name = spooky::NodeDescriptor(TCHAR_TO_UTF8(*(name)));\n\tspooky::Transform3D T = plant.getNodeLocalPose(bone_name);\n\tFTransform result(convert(T));\n\tresult.SetTranslation(result.GetTranslation() / plant.config.units.output_m);\n\treturn result;\n}\n\n\n//===========================\n//Data retrieval functions\n//===========================\n\nFCalibrationResult USpookyFusionPlant::getCalibrationResult(FString s1, FString s2)\n{\n\tspooky::CalibrationResult T = plant.getCalibrationResult(spooky::SystemDescriptor(TCHAR_TO_UTF8(*s1)),spooky::SystemDescriptor(TCHAR_TO_UTF8(*s2)));\n\tEigen::Quaternionf q(T.transform.matrix().block<3,3>(0,0));\n\tEigen::Vector3f v(T.transform.matrix().block<3, 1>(0, 3) / plant.config.units.output_m);\n\tFQuat fq(q.x(), q.y(), q.z(), q.w());\n\t\n\tFCalibrationResult result;\n\tresult.transform.SetRotation(fq);\n\tresult.transform.SetTranslation(FVector(v[0], v[1], v[2]));\n\tresult.calibrated = T.calibrated();\n\tresult.refining = T.refining();\n\tresult.quality = T.quality;\n\tresult.system1 = FString(T.systems.first.name.c_str());\n\tresult.system2 = FString(T.systems.second.name.c_str());\n\treturn result;\n}\n\nFString USpookyFusionPlant::getCorrelationResult(FString s1, int sensorID)\n{\n\treturn plant.getCorrelationResult(spooky::SystemDescriptor(TCHAR_TO_UTF8(*s1)),sensorID).name.c_str();\n}\n\nFTransform USpookyFusionPlant::getNodeGlobalPose(FString node)\n{\n\tspooky::Transform3D result = plant.getNodeGlobalPose(spooky::NodeDescriptor(TCHAR_TO_UTF8(*node)));\n\tFMatrix unrealMatrix = convert(result);\n\tunrealMatrix.ScaleTranslation(FVector(1,1,1) * 1 / plant.config.units.output_m);\n\t//UE_LOG(LogTemp, Warning, TEXT(\"getNodePose : %s\"), *(unrealMatrix.ToString()));\n\treturn FTransform(unrealMatrix);\n}\n//===========================\n//Data saving/loading functions\n//===========================\n\n//Sets save/load location\t\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nvoid USpookyFusionPlant::setSaveDirectory(FString dir) {\n\tplant.setSaveDirectory(TCHAR_TO_UTF8(*dir));\n}\n\n//Saves the calibration result mapping T:s1->s2\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nvoid USpookyFusionPlant::saveCalibrationResult(FString s1, FString s2){\n\tplant.saveCalibration(spooky::SystemDescriptor(TCHAR_TO_UTF8(*s1)),spooky::SystemDescriptor(TCHAR_TO_UTF8(*s2)));\n}\n\n//Loads the calibration result mapping T:s1->s2\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nvoid USpookyFusionPlant::loadCalibrationResult(FString s1, FString s2){\n\tplant.loadCalibration(spooky::SystemDescriptor(TCHAR_TO_UTF8(*s1)), spooky::SystemDescriptor(TCHAR_TO_UTF8(*s2)));\n}\n\n//===========================\n//Utility\n//===========================\n\n//Compute axis angle representation (x,y,z,alpha)\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nFVector4 USpookyFusionPlant::getRotatorAxisAngle(FRotator R) {\n\tfloat angle;\n\tFVector axis;\n\tR.Quaternion().ToAxisAndAngle(axis,angle);\n\treturn FVector4(axis[0], axis[1], axis[2], angle * 180 / M_PI);\n}\n\nvoid USpookyFusionPlant::CopyPose(UPoseableMeshComponent* target, const UPoseableMeshComponent* input)\n{\n\tif (target->RequiredBones.IsValid())\n\t{\n\t\tif (target->SkeletalMesh == input->SkeletalMesh)\n\t\t{\n\t\t\tcheck(target->BoneSpaceTransforms.Num() == input->BoneSpaceTransforms.Num());\n\n\t\t\t// Quick path, we know everything matches, just copy the local atoms\n\t\t\ttarget->BoneSpaceTransforms = input->BoneSpaceTransforms;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// The meshes don't match, search bone-by-bone (slow path)\n\n\t\t\t// first set the localatoms to ref pose from our current mesh\n\t\t\ttarget->BoneSpaceTransforms = target->SkeletalMesh->RefSkeleton.GetRefBonePose();\n\n\t\t\t// Now overwrite any matching bones\n\t\t\tconst int32 NumSourceBones = input->SkeletalMesh->RefSkeleton.GetNum();\n\n\t\t\tfor (int32 SourceBoneIndex = 0; SourceBoneIndex < NumSourceBones; ++SourceBoneIndex)\n\t\t\t{\n\t\t\t\tconst FName SourceBoneName = input->GetBoneName(SourceBoneIndex);\n\t\t\t\tconst int32 TargetBoneIndex = target->GetBoneIndex(SourceBoneName);\n\n\t\t\t\tif (TargetBoneIndex != INDEX_NONE)\n\t\t\t\t{\n\t\t\t\t\ttarget->BoneSpaceTransforms[TargetBoneIndex] = input->BoneSpaceTransforms[SourceBoneIndex];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttarget->RefreshBoneTransforms();\n\t}\n}\n//TODO: optimise with const ref\nMeasurement::Ptr USpookyFusionPlant::CreatePositionMeasurement(FString system_name, int sensorID, float timestamp_sec, FVector position, FVector uncertainty, float confidence)\n{\n\t//Create basic measurement\n\tEigen::Vector3f meas(position[0],position[1],position[2]);\n\tmeas = meas * plant.config.units.input_m;\n\n\tEigen::Matrix<float, 3, 3> un = Eigen::Matrix<float,3,3>::Identity();\n\tun.diagonal() = Eigen::Vector3f(uncertainty[0], uncertainty[1], uncertainty[2]);\n\tMeasurement::Ptr result = Measurement::createCartesianMeasurement(meas, un);\n\t\n\t//Add metadata\n\tSetCommonMeasurementData(result, system_name, sensorID, timestamp_sec, confidence);\n\n\treturn std::move(result);\n}\n\nMeasurement::Ptr USpookyFusionPlant::CreateRotationMeasurement(FString system_name, int sensorID, float timestamp_sec, FQuat rotation, FVector4 uncertainty, float confidence)\n{\n\t//Create basic measurement\n\t//BEWARE: dumb format mismatch:\n\tEigen::Quaternionf meas(rotation.W, rotation.X, rotation.Y, rotation.Z);\n\tEigen::Matrix<float, 4, 4> un = Eigen::Matrix<float, 4, 4>::Identity();\n\tun.diagonal() = Eigen::Vector4f(&uncertainty[0]);\n\tMeasurement::Ptr result = Measurement::createQuaternionMeasurement(meas, un);\n\n\t//Add metadata\n\tSetCommonMeasurementData(result, system_name, sensorID, timestamp_sec, confidence);\n\t\n\treturn std::move(result);\n}\n\nMeasurement::Ptr USpookyFusionPlant::CreateScaleMeasurement(FString system_name, int sensorID, float timestamp_sec, FVector scale, FVector uncertainty, float confidence)\n{\n\t//Create basic measurement\n\tEigen::Vector3f meas(&scale[0]);\n\tmeas = meas * plant.config.units.input_m;\n\tEigen::Matrix<float, 3, 3> un = Eigen::Matrix<float, 3, 3>::Identity();\n\tun.diagonal() = Eigen::Vector3f(&uncertainty[0]);\n\tMeasurement::Ptr result = Measurement::createScaleMeasurement(meas, un);\n\n\t//Add metadata\n\tSetCommonMeasurementData(result, system_name, sensorID, timestamp_sec, confidence);\n\t\n\treturn std::move(result);\n}\n\nMeasurement::Ptr USpookyFusionPlant::CreatePoseMeasurement(FString system_name, int sensorID, float timestamp_sec, FVector v, FQuat q, Eigen::Matrix<float, 7, 1> uncertainty, float confidence)\n{\n\t//Convert transform to state vector (v,q)\n\tEigen::Vector3f ev(&v[0]);\n\tev = ev * plant.config.units.input_m;\n\t//BEWARE: dumb format mismatch:\n\tEigen::Quaternionf eq(q.W,q.X,q.Y,q.Z);\n\t//Create basic measurement\n\tEigen::Matrix<float, 7, 7> un = Eigen::Matrix<float, 7, 7>::Identity();\n\tun.diagonal() = uncertainty;\n\tMeasurement::Ptr result = Measurement::createPoseMeasurement(ev, eq, un);\n\t\n\t//Add metadata\n\tSetCommonMeasurementData(result, system_name, sensorID, timestamp_sec, confidence);\n\n\treturn std::move(result);\n}\n\nvoid USpookyFusionPlant::SetCommonMeasurementData(Measurement::Ptr& m, FString system_name, int sensorID, float timestamp_sec, float confidence){\n\t//Add metadata\n\tplant.setMeasurementSensorInfo(m, spooky::SystemDescriptor(TCHAR_TO_UTF8(*system_name)), spooky::SensorID(sensorID));\n\tbool measurementConsistent = m->setMetaData(timestamp_sec, confidence);\n\tif (!measurementConsistent) {\n\t\tstd::cout << \"WARNING - Measurement not created correctly - \" << __LINE__ << std::endl;\n\t}\n}\n\nstd::vector<spooky::NodeDescriptor> USpookyFusionPlant::convertToNodeDescriptors(const TArray<FString>& names){\n\tstd::vector<spooky::NodeDescriptor> result;\n\tfor(auto& name : names){\n\t\tresult.push_back(spooky::NodeDescriptor(TCHAR_TO_UTF8(*name)));\n\t}\n\treturn result;\n}\n\nFMatrix USpookyFusionPlant::convert(const spooky::Transform3D& T) {\n\tFMatrix unrealMatrix;\n\tmemcpy(&(unrealMatrix.M[0][0]), T.data(), sizeof(float) * 16);\n\treturn unrealMatrix;\n}\n\nspooky::Transform3D USpookyFusionPlant::convert(const FMatrix& T) {\n\tspooky::Transform3D matrix;\n\tmemcpy(matrix.data(), &(T.M[0][0]), sizeof(float) * 16);\n\treturn matrix;\n}\n\n//===========================\n//DEBUG\n//===========================\n\n//For testing blueprints: TODO delete\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nFString USpookyFusionPlant::GetCalibrationStateSummary() {\n\tstd::string s = plant.getCalibratorStateSummary();\n\treturn s.c_str();\n}\n//For testing blueprints: TODO delete\nUFUNCTION(BlueprintCallable, Category = \"Spooky\")\nFString USpookyFusionPlant::GetCalibrationTimingSummary() {\n\tstd::string s = plant.getTimingSummary();\n\treturn s.c_str();\n}\n",
			"file": "Plugins/Spooky/Source/Spooky/Private/SpookyFusionPlant.cpp",
			"file_size": 17396,
			"file_write_time": 131528600162825331,
			"settings":
			{
				"buffer_size": 16972,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Users/NUbots/Mining/mine.bat",
			"settings":
			{
				"buffer_size": 257,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Users/NUbots/AppData/Local/Temp/7zOCF315FAF/README.md",
			"settings":
			{
				"buffer_size": 994,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "// Copyright (C) 2016 Fredrik Lindh. All Rights Reserved.\n// Created by Fredrik Lindh (Temaran) on 2016-01-28\n\n#pragma once\n\n#include \"ModuleManager.h\"\n#include \"Runtime/Engine/Classes/Engine/Texture2D.h\"\n\nclass IWebcamera : public IModuleInterface\n{\npublic:\n\n\t/**\n\t* Singleton-like access to this module's interface.  This is just for convenience!\n\t* Beware of calling this during the shutdown phase, though. Your module might have been\n\t* unloaded already.\n\t*\n\t* @return Returns singleton instance, loading the module on demand if needed\n\t*/\n\tstatic inline IWebcamera& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked<IWebcamera>(\"Webcamera\");\n\t}\n\n\t/**\n\t* Checks to see if this module is loaded and ready.  It is only valid to call Get() if\n\t* IsAvailable() returns true.\n\t*\n\t* @return True if the module is loaded and ready to use\n\t*/\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded(\"Webcamera\");\n\t}\n\n\t//==============================================================================\n\t// Public Webcamera API\t\t\t\t\t\t\t\t\n\t//==============================================================================\n\npublic:\n\t/**\n\t* Destroys all connections and tries to find new ones. You need to reconnect to previously connected devices if you do this.\n\t*\n\t* @return The number of devices found.\n\t*/\n\tvirtual int32 ReacquireDevices() = 0;\n\n\t/**\n\t* Connects to a device. Please check how many devices are available before you connect to an index.\n\t*\n\t* DeviceIndex The index of the camera to connect to. There is no order opr stability guarantee for these indices.\n\t* @return The camera that the camera will continuously write updates to. If you don't store this in a UPROPERTY, it will get garbage collected, so watch out for that!\n\t*/\n\tvirtual UTexture2D* Connect(int32 DeviceIndex) = 0;\n\n\t/**\n\t* Disconnects from a device. Please check how many devices are available before you attempt this.\n\t*\n\t* DeviceIndex The index of the camera to disconnect from. There is no order or stability guarantee for these indices.\n\t*/\n\tvirtual void Disconnect(int32 DeviceIndex) = 0;\n\n\t/**\n\t* Returns the number of web cameras the plugin could find connected to the system.\n\t*\n\t* @return The number of devices found.\n\t*/\n\tvirtual int32 GetNumDevices() = 0;\n};\n",
			"file": "Plugins/Webcamera/Source/Public/IWebcamera.h",
			"file_size": 2270,
			"file_write_time": 130984845770000000,
			"settings":
			{
				"buffer_size": 2271,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Get rid of:\n- BP_Avateering_Poseable",
			"settings":
			{
				"buffer_size": 36,
				"line_ending": "Windows",
				"name": "Get rid of:"
			}
		},
		{
			"contents": "#include \"UnrealFusion.h\"\n#include \"AllowWindowsPlatformTypes.h\"\n#include \"Logging.h\"\n\n#ifdef _WIN32\n    #if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n        #define _CRT_SECURE_NO_WARNINGS // _CRT_SECURE_NO_WARNINGS for sscanf errors in MSVC2013 Express\n    #endif\n    #ifndef WIN32_LEAN_AND_MEAN\n        #define WIN32_LEAN_AND_MEAN\n    #endif\n    #include <fcntl.h>\n    #include <WinSock2.h>\n    #include <WS2tcpip.h>\n    #pragma comment( lib, \"ws2_32\" )\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include <string.h>\n    #include <sys/types.h>\n    #include <io.h>\n    #ifndef _SSIZE_T_DEFINED\n        typedef int ssize_t;\n        #define _SSIZE_T_DEFINED\n    #endif\n    #ifndef _SOCKET_T_DEFINED\n        typedef SOCKET socket_t;\n        #define _SOCKET_T_DEFINED\n    #endif\n    #ifndef snprintf\n        #define snprintf _snprintf_s\n    #endif\n    #if _MSC_VER >=1600\n        // vs2010 or later\n        #include <stdint.h>\n    #else\n        typedef __int8 int8_t;\n        typedef unsigned __int8 uint8_t;\n        typedef __int32 int32_t;\n        typedef unsigned __int32 uint32_t;\n        typedef __int64 int64_t;\n        typedef unsigned __int64 uint64_t;\n    #endif\n    #define socketerrno WSAGetLastError()\n    #define SOCKET_EAGAIN_EINPROGRESS WSAEINPROGRESS\n    #define SOCKET_EWOULDBLOCK WSAEWOULDBLOCK\n#else\n    #include <fcntl.h>\n    #include <netdb.h>\n    #include <netinet/tcp.h>\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include <string.h>\n    #include <sys/socket.h>\n    #include <sys/time.h>\n    #include <sys/types.h>\n    #include <unistd.h>\n    #include <stdint.h>\n    #ifndef _SOCKET_T_DEFINED\n        typedef int socket_t;\n        #define _SOCKET_T_DEFINED\n    #endif\n    #ifndef INVALID_SOCKET\n        #define INVALID_SOCKET (-1)\n    #endif\n    #ifndef SOCKET_ERROR\n        #define SOCKET_ERROR   (-1)\n    #endif\n    #define closesocket(s) ::close(s)\n    #include <errno.h>\n    #define socketerrno errno\n    #define SOCKET_EAGAIN_EINPROGRESS EAGAIN\n    #define SOCKET_EWOULDBLOCK EWOULDBLOCK\n#endif\n\n#include \"HideWindowsPlatformTypes.h\"\n\n#include <vector>\n#include <string>\n\n#include \"easywsclient.hpp\"\n#include \"Logging.h\"\n\nusing easywsclient::Callback_Imp;\nusing easywsclient::BytesCallback_Imp;\n\nnamespace { // private module-only namespace\n\nsocket_t hostname_connect(const std::string& hostname, int port) {\n    struct addrinfo hints;\n    struct addrinfo *result;\n    struct addrinfo *p;\n    int ret;\n    socket_t sockfd = INVALID_SOCKET;\n    char sport[16];\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n    snprintf(sport, 16, \"%d\", port);\n    if ((ret = getaddrinfo(hostname.c_str(), sport, &hints, &result)) != 0)\n    {\n      //fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(ret));\n      return 1;\n    }\n    for(p = result; p != NULL; p = p->ai_next)\n    {\n        sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n        if (sockfd == INVALID_SOCKET) { continue; }\n        if (connect(sockfd, p->ai_addr, p->ai_addrlen) != SOCKET_ERROR) {\n            break;\n        }\n        closesocket(sockfd);\n        sockfd = INVALID_SOCKET;\n    }\n    freeaddrinfo(result);\n    return sockfd;\n}\n\n\nclass _DummyWebSocket : public easywsclient::WebSocket\n{\n  public:\n    void poll(int timeout) { }\n    void send(const std::string& message) { }\n    void sendBinary(const std::string& message) { }\n    void sendBinary(const std::vector<uint8_t>& message) { }\n    void sendPing() { }\n    void close() { } \n    readyStateValues getReadyState() const { return CLOSED; }\n    void _dispatch(Callback_Imp & callable) { }\n    void _dispatchBinary(BytesCallback_Imp& callable) { }\n};\n\n\nclass _RealWebSocket : public easywsclient::WebSocket\n{\n  public:\n    // http://tools.ietf.org/html/rfc6455#section-5.2  Base Framing Protocol\n    //\n    //  0                   1                   2                   3\n    //  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    // +-+-+-+-+-------+-+-------------+-------------------------------+\n    // |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n    // |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n    // |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n    // | |1|2|3|       |K|             |                               |\n    // +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n    // |     Extended payload length continued, if payload len == 127  |\n    // + - - - - - - - - - - - - - - - +-------------------------------+\n    // |                               |Masking-key, if MASK set to 1  |\n    // +-------------------------------+-------------------------------+\n    // | Masking-key (continued)       |          Payload Data         |\n    // +-------------------------------- - - - - - - - - - - - - - - - +\n    // :                     Payload Data continued ...                :\n    // + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n    // |                     Payload Data continued ...                |\n    // +---------------------------------------------------------------+\n    struct wsheader_type {\n        unsigned header_size;\n        bool fin;\n        bool mask;\n        enum opcode_type {\n            CONTINUATION = 0x0,\n            TEXT_FRAME = 0x1,\n            BINARY_FRAME = 0x2,\n            CLOSE = 8,\n            PING = 9,\n            PONG = 0xa,\n        } opcode;\n        int N0;\n        uint64_t N;\n        uint8_t masking_key[4];\n    };\n\n    std::vector<uint8_t> rxbuf;\n    std::vector<uint8_t> txbuf;\n    std::vector<uint8_t> receivedData;\n\n    socket_t sockfd;\n    readyStateValues readyState;\n    bool useMask;\n\n    _RealWebSocket(socket_t sockfd, bool useMask) : sockfd(sockfd), readyState(OPEN), useMask(useMask) {\n    }\n\n    readyStateValues getReadyState() const {\n      return readyState;\n    }\n\n    void poll(int timeout) { // timeout in milliseconds\n        if (readyState == CLOSED) {\n            if (timeout > 0) {\n                timeval tv = { timeout/1000, (timeout%1000) * 1000 };\n                select(0, NULL, NULL, NULL, &tv);\n            }\n            return;\n        }\n        if (timeout != 0) {\n            fd_set rfds;\n            fd_set wfds;\n            timeval tv = { timeout/1000, (timeout%1000) * 1000 };\n            FD_ZERO(&rfds);\n            FD_ZERO(&wfds);\n            FD_SET(sockfd, &rfds);\n            if (txbuf.size()) { FD_SET(sockfd, &wfds); }\n            select(sockfd + 1, &rfds, &wfds, 0, timeout > 0 ? &tv : 0);\n        }\n        while (true) {\n            // FD_ISSET(0, &rfds) will be true\n            int N = rxbuf.size();\n            ssize_t ret;\n            rxbuf.resize(N + 1500);\n            ret = recv(sockfd, (char*)&rxbuf[0] + N, 1500, 0);\n            if (false) { }\n            else if (ret < 0 && (socketerrno == SOCKET_EWOULDBLOCK || socketerrno == SOCKET_EAGAIN_EINPROGRESS)) {\n                rxbuf.resize(N);\n                break;\n            }\n            else if (ret <= 0) {\n                rxbuf.resize(N);\n                closesocket(sockfd);\n                readyState = CLOSED;\n                SPOOKY_LOG(ret < 0 ? \"Connection error!\\n\" : \"Connection closed!\\n\");\n                break;\n            } \n            else {\n                rxbuf.resize(N + ret);\n            }\n        }\n        while (txbuf.size()) {\n            int ret = ::send(sockfd, (char*)&txbuf[0], txbuf.size(), 0);\n            if (false) { } // ??\n            else if (ret < 0 && (socketerrno == SOCKET_EWOULDBLOCK || socketerrno == SOCKET_EAGAIN_EINPROGRESS)) {\n                break;\n            }\n            else if (ret <= 0) {\n                closesocket(sockfd);\n                readyState = CLOSED;\n                SPOOKY_LOG(ret < 0 ? \"Connection error!\\n\" : \"Connection closed!\\n\");\n                break;\n            }\n            else {\n                txbuf.erase(txbuf.begin(), txbuf.begin() + ret);\n            }\n        }\n        if (!txbuf.size() && readyState == CLOSING) {\n            closesocket(sockfd);\n            readyState = CLOSED;\n        }\n    }\n\n    // Callable must have signature: void(const std::string & message).\n    // Should work with C functions, C++ functors, and C++11 std::function and\n    // lambda:\n    //template<class Callable>\n    //void dispatch(Callable callable)\n    virtual void _dispatch(Callback_Imp & callable) {\n        struct CallbackAdapter : public BytesCallback_Imp\n            // Adapt void(const std::string<uint8_t>&) to void(const std::string&)\n        {\n            Callback_Imp& callable;\n            CallbackAdapter(Callback_Imp& callable) : callable(callable) { }\n            void operator()(const std::vector<uint8_t>& message) {\n                std::string stringMessage(message.begin(), message.end());\n                callable(stringMessage);\n            }\n        };\n        CallbackAdapter bytesCallback(callable);\n        _dispatchBinary(bytesCallback);\n    }\n\n    virtual void _dispatchBinary(BytesCallback_Imp & callable) {\n        // TODO: consider acquiring a lock on rxbuf...\n        while (true) {\n            wsheader_type ws;\n            if (rxbuf.size() < 2) { return; /* Need at least 2 */ }\n            const uint8_t * data = (uint8_t *) &rxbuf[0]; // peek, but don't consume\n            ws.fin = (data[0] & 0x80) == 0x80;\n            ws.opcode = (wsheader_type::opcode_type) (data[0] & 0x0f);\n            ws.mask = (data[1] & 0x80) == 0x80;\n            ws.N0 = (data[1] & 0x7f);\n            ws.header_size = 2 + (ws.N0 == 126? 2 : 0) + (ws.N0 == 127? 8 : 0) + (ws.mask? 4 : 0);\n            if (rxbuf.size() < ws.header_size) { return; /* Need: ws.header_size - rxbuf.size() */ }\n            int i = 0;\n            if (ws.N0 < 126) {\n                ws.N = ws.N0;\n                i = 2;\n            }\n            else if (ws.N0 == 126) {\n                ws.N = 0;\n                ws.N |= ((uint64_t) data[2]) << 8;\n                ws.N |= ((uint64_t) data[3]) << 0;\n                i = 4;\n            }\n            else if (ws.N0 == 127) {\n                ws.N = 0;\n                ws.N |= ((uint64_t) data[2]) << 56;\n                ws.N |= ((uint64_t) data[3]) << 48;\n                ws.N |= ((uint64_t) data[4]) << 40;\n                ws.N |= ((uint64_t) data[5]) << 32;\n                ws.N |= ((uint64_t) data[6]) << 24;\n                ws.N |= ((uint64_t) data[7]) << 16;\n                ws.N |= ((uint64_t) data[8]) << 8;\n                ws.N |= ((uint64_t) data[9]) << 0;\n                i = 10;\n            }\n            if (ws.mask) {\n                ws.masking_key[0] = ((uint8_t) data[i+0]) << 0;\n                ws.masking_key[1] = ((uint8_t) data[i+1]) << 0;\n                ws.masking_key[2] = ((uint8_t) data[i+2]) << 0;\n                ws.masking_key[3] = ((uint8_t) data[i+3]) << 0;\n            }\n            else {\n                ws.masking_key[0] = 0;\n                ws.masking_key[1] = 0;\n                ws.masking_key[2] = 0;\n                ws.masking_key[3] = 0;\n            }\n            if (rxbuf.size() < ws.header_size+ws.N) { return; /* Need: ws.header_size+ws.N - rxbuf.size() */ }\n\n            // We got a whole message, now do something with it:\n            if (false) { }\n            else if (\n                   ws.opcode == wsheader_type::TEXT_FRAME \n                || ws.opcode == wsheader_type::BINARY_FRAME\n                || ws.opcode == wsheader_type::CONTINUATION\n            ) {\n                if (ws.mask) { for (size_t i = 0; i != ws.N; ++i) { rxbuf[i+ws.header_size] ^= ws.masking_key[i&0x3]; } }\n                receivedData.insert(receivedData.end(), rxbuf.begin()+ws.header_size, rxbuf.begin()+ws.header_size+(size_t)ws.N);// just feed\n                if (ws.fin) {\n                    callable((const std::vector<uint8_t>) receivedData);\n                    receivedData.erase(receivedData.begin(), receivedData.end());\n                    std::vector<uint8_t> ().swap(receivedData);// free memory\n                }\n            }\n            else if (ws.opcode == wsheader_type::PING) {\n                if (ws.mask) { for (size_t i = 0; i != ws.N; ++i) { rxbuf[i+ws.header_size] ^= ws.masking_key[i&0x3]; } }\n                std::string data(rxbuf.begin()+ws.header_size, rxbuf.begin()+ws.header_size+(size_t)ws.N);\n                sendData(wsheader_type::PONG, data.size(), data.begin(), data.end());\n            }\n            else if (ws.opcode == wsheader_type::PONG) { }\n            else if (ws.opcode == wsheader_type::CLOSE) { close(); }\n            else { fprintf(stderr, \"ERROR: Got unexpected WebSocket message.\\n\"); close(); }\n\n            rxbuf.erase(rxbuf.begin(), rxbuf.begin() + ws.header_size+(size_t)ws.N);\n        }\n    }\n\n    void sendPing() {\n        std::string empty;\n        sendData(wsheader_type::PING, empty.size(), empty.begin(), empty.end());\n    }\n\n    void send(const std::string& message) {\n        sendData(wsheader_type::TEXT_FRAME, message.size(), message.begin(), message.end());\n    }\n\n    void sendBinary(const std::string& message) {\n        sendData(wsheader_type::BINARY_FRAME, message.size(), message.begin(), message.end());\n    }\n\n    void sendBinary(const std::vector<uint8_t>& message) {\n        sendData(wsheader_type::BINARY_FRAME, message.size(), message.begin(), message.end());\n    }\n\n    template<class Iterator>\n    void sendData(wsheader_type::opcode_type type, uint64_t message_size, Iterator message_begin, Iterator message_end) {\n        // TODO:\n        // Masking key should (must) be derived from a high quality random\n        // number generator, to mitigate attacks on non-WebSocket friendly\n        // middleware:\n        const uint8_t masking_key[4] = { 0x12, 0x34, 0x56, 0x78 };\n        // TODO: consider acquiring a lock on txbuf...\n        if (readyState == CLOSING || readyState == CLOSED) { return; }\n        std::vector<uint8_t> header;\n        header.assign(2 + (message_size >= 126 ? 2 : 0) + (message_size >= 65536 ? 6 : 0) + (useMask ? 4 : 0), 0);\n        header[0] = 0x80 | type;\n        if (false) { }\n        else if (message_size < 126) {\n            header[1] = (message_size & 0xff) | (useMask ? 0x80 : 0);\n            if (useMask) {\n                header[2] = masking_key[0];\n                header[3] = masking_key[1];\n                header[4] = masking_key[2];\n                header[5] = masking_key[3];\n            }\n        }\n        else if (message_size < 65536) {\n            header[1] = 126 | (useMask ? 0x80 : 0);\n            header[2] = (message_size >> 8) & 0xff;\n            header[3] = (message_size >> 0) & 0xff;\n            if (useMask) {\n                header[4] = masking_key[0];\n                header[5] = masking_key[1];\n                header[6] = masking_key[2];\n                header[7] = masking_key[3];\n            }\n        }\n        else { // TODO: run coverage testing here\n            header[1] = 127 | (useMask ? 0x80 : 0);\n            header[2] = (message_size >> 56) & 0xff;\n            header[3] = (message_size >> 48) & 0xff;\n            header[4] = (message_size >> 40) & 0xff;\n            header[5] = (message_size >> 32) & 0xff;\n            header[6] = (message_size >> 24) & 0xff;\n            header[7] = (message_size >> 16) & 0xff;\n            header[8] = (message_size >>  8) & 0xff;\n            header[9] = (message_size >>  0) & 0xff;\n            if (useMask) {\n                header[10] = masking_key[0];\n                header[11] = masking_key[1];\n                header[12] = masking_key[2];\n                header[13] = masking_key[3];\n            }\n        }\n        // N.B. - txbuf will keep growing until it can be transmitted over the socket:\n        txbuf.insert(txbuf.end(), header.begin(), header.end());\n        txbuf.insert(txbuf.end(), message_begin, message_end);\n        if (useMask) {\n\t\t\tfor (size_t i = 0; i != message_size; ++i) { *(txbuf.end() - message_size + i) ^= masking_key[i&0x3]; }\n        }\n    }\n\n    void close() {\n        if(readyState == CLOSING || readyState == CLOSED) { return; }\n        readyState = CLOSING;\n        uint8_t closeFrame[6] = {0x88, 0x80, 0x00, 0x00, 0x00, 0x00}; // last 4 bytes are a masking key\n        std::vector<uint8_t> header(closeFrame, closeFrame+6);\n        txbuf.insert(txbuf.end(), header.begin(), header.end());\n    }\n\n};\n\n\neasywsclient::WebSocket::pointer from_url(const std::string& url, bool useMask, const std::string& origin) {\n    char host[128];\n    int port;\n    char path[128];\n    if (url.size() >= 128) {\n      fprintf(stderr, \"ERROR: url size limit exceeded: %s\\n\", url.c_str());\n      return NULL;\n    }\n    if (origin.size() >= 200) {\n      fprintf(stderr, \"ERROR: origin size limit exceeded: %s\\n\", origin.c_str());\n      return NULL;\n    }\n    if (false) { }\n    else if (sscanf(url.c_str(), \"ws://%[^:/]:%d/%s\", host, &port, path) == 3) {\n    }\n    else if (sscanf(url.c_str(), \"ws://%[^:/]/%s\", host, path) == 2) {\n        port = 80;\n    }\n    else if (sscanf(url.c_str(), \"ws://%[^:/]:%d\", host, &port) == 2) {\n        path[0] = '\\0';\n    }\n    else if (sscanf(url.c_str(), \"ws://%[^:/]\", host) == 1) {\n        port = 80;\n        path[0] = '\\0';\n    }\n    else {\n        fprintf(stderr, \"ERROR: Could not parse WebSocket url: %s\\n\", url.c_str());\n        return NULL;\n    }\n    fprintf(stderr, \"easywsclient: connecting: host=%s port=%d path=/%s\\n\", host, port, path);\n    socket_t sockfd = hostname_connect(host, port);\n    if (sockfd == INVALID_SOCKET) {\n        fprintf(stderr, \"Unable to connect to %s:%d\\n\", host, port);\n        return NULL;\n    }\n    {\n        // XXX: this should be done non-blocking,\n        char line[256];\n        int status;\n        int i;\n        snprintf(line, 256, \"GET /%s HTTP/1.1\\r\\n\", path); ::send(sockfd, line, strlen(line), 0);\n        if (port == 80) {\n            snprintf(line, 256, \"Host: %s\\r\\n\", host); ::send(sockfd, line, strlen(line), 0);\n        }\n        else {\n            snprintf(line, 256, \"Host: %s:%d\\r\\n\", host, port); ::send(sockfd, line, strlen(line), 0);\n        }\n        snprintf(line, 256, \"Upgrade: websocket\\r\\n\"); ::send(sockfd, line, strlen(line), 0);\n        snprintf(line, 256, \"Connection: Upgrade\\r\\n\"); ::send(sockfd, line, strlen(line), 0);\n        if (!origin.empty()) {\n            snprintf(line, 256, \"Origin: %s\\r\\n\", origin.c_str()); ::send(sockfd, line, strlen(line), 0);\n        }\n        snprintf(line, 256, \"Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\\r\\n\"); ::send(sockfd, line, strlen(line), 0);\n        snprintf(line, 256, \"Sec-WebSocket-Version: 13\\r\\n\"); ::send(sockfd, line, strlen(line), 0);\n        snprintf(line, 256, \"\\r\\n\"); ::send(sockfd, line, strlen(line), 0);\n        for (i = 0; i < 2 || (i < 255 && line[i-2] != '\\r' && line[i-1] != '\\n'); ++i) { if (recv(sockfd, line+i, 1, 0) == 0) { return NULL; } }\n        line[i] = 0;\n        if (i == 255) { fprintf(stderr, \"ERROR: Got invalid status line connecting to: %s\\n\", url.c_str()); return NULL; }\n        if (sscanf(line, \"HTTP/1.1 %d\", &status) != 1 || status != 101) { fprintf(stderr, \"ERROR: Got bad status connecting to %s: %s\", url.c_str(), line); return NULL; }\n        // TODO: verify response headers,\n        while (true) {\n            for (i = 0; i < 2 || (i < 255 && line[i-2] != '\\r' && line[i-1] != '\\n'); ++i) { if (recv(sockfd, line+i, 1, 0) == 0) { return NULL; } }\n            if (line[0] == '\\r' && line[1] == '\\n') { break; }\n        }\n    }\n    int flag = 1;\n    setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, (char*) &flag, sizeof(flag)); // Disable Nagle's algorithm\n#ifdef _WIN32\n    u_long on = 1;\n    ioctlsocket(sockfd, FIONBIO, &on);\n#else\n    fcntl(sockfd, F_SETFL, O_NONBLOCK);\n#endif\n    fprintf(stderr, \"Connected to: %s\\n\", url.c_str());\n    return easywsclient::WebSocket::pointer(new _RealWebSocket(sockfd, useMask));\n}\n\n} // end of module-only namespace\n\n\n\nnamespace easywsclient {\n\nWebSocket::pointer WebSocket::create_dummy() {\n    static pointer dummy = pointer(new _DummyWebSocket);\n    return dummy;\n}\n\n\nWebSocket::pointer WebSocket::from_url(const std::string& url, const std::string& origin) {\n    return ::from_url(url, true, origin);\n}\n\nWebSocket::pointer WebSocket::from_url_no_mask(const std::string& url, const std::string& origin) {\n    return ::from_url(url, false, origin);\n}\n\n\n} // namespace easywsclient\n",
			"file": "Source/UnrealFusion/easywsclient.cpp",
			"file_size": 20294,
			"file_write_time": 131491434965761102,
			"settings":
			{
				"buffer_size": 20294,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "// Test\n\n#include \"UnrealFusion.h\"\n#include \"Logging.h\"\n#include \"Websocket.h\"\n#include <assert.h>\n#include <string>\n\n#include \"AllowWindowsPlatformTypes.h\"\n#pragma comment( lib, \"ws2_32\" )\n#include <WinSock2.h>\n#include \"HideWindowsPlatformTypes.h\"\n\n// Sets default values for this component's properties\nUWebsocket::UWebsocket()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\t// ...\n}\n\nvoid UWebsocket::handle_message(const std::string& message){\n\tSPOOKY_LOG(message);\n}\n// Called when the game starts\nvoid UWebsocket::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tint rc;\n\tWSADATA wsaData;\n\n\trc = WSAStartup(MAKEWORD(2, 2), &wsaData);\n\tif (rc) {\n\t\tSPOOKY_LOG(\"WSAStartup Failed.\");\n\t\treturn;\n\t}\n\n\tws = std::unique_ptr<easywsclient::WebSocket>(easywsclient::WebSocket::from_url_no_mask(\"ws://127.0.0.1:82\"));\n\n\tif (ws) {\n\t\tSPOOKY_LOG(\"Connection successful \" + std::to_string(ws->getReadyState()));\n\t}\n\telse {\n\t\tSPOOKY_LOG(\"Connection unsuccessful \");\n\t}\n\n\n/*\n\t\tws->close();\n\t\tWSACleanup();*/\n\n\t\n}\n\n\n// Called every frame\nvoid UWebsocket::TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction )\n{\n\tSuper::TickComponent( DeltaTime, TickType, ThisTickFunction );\n\t\n\t// ...\n\tif (ws) {\n\t\tws->send(\"r\");\n\t\tws->poll(1000);\n\t\tws->dispatch([this](const std::string & message) {\n\t\t\tSPOOKY_LOG(message);\n\t\t\tlatestString = message;\n\t\t});\n\t}\n}\n\nUFUNCTION(BlueprintCallable, Category = \"Websocket\")\nFString UWebsocket::getLatestString()\n{\n\treturn FString(latestString.c_str());\n}\n\n",
			"file": "Source/UnrealFusion/Websocket.cpp",
			"file_size": 1764,
			"file_write_time": 131491434965826220,
			"settings":
			{
				"buffer_size": 1684,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": ".gitignore",
			"settings":
			{
				"buffer_size": 503,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": ".git/config",
			"settings":
			{
				"buffer_size": 641,
				"line_ending": "Unix"
			}
		},
		{
			"file": "UnrealFusion.uproject",
			"settings":
			{
				"buffer_size": 760,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "/*  This file is part of SpookyUnreal, a sensor fusion plugin for VR in the Unreal Engine\n    Copyright (C) 2017 Jake Fountain\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n#pragma once\n\n#include \"Spooky.h\"\n\n#include \"Components/ActorComponent.h\"\n#include \"Components/PoseableMeshComponent.h\"\n#include \"BoneContainer.h\"\n\n#include \"Spooky/Core.h\"\n#include \"Spooky/FusionTypes.h\"\n\n#include <iostream>\n#include <vector>\n#include <string>\n\n//Must be last include\n#include \"SpookyFusionPlant.generated.h\"\n\n//Unreal engine specific struct containing the results of a calibration between two 3D sensor systems\nUSTRUCT()\nstruct FCalibrationResult {\n\tGENERATED_BODY()\n\t\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Spooky\") FTransform transform;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Spooky\") bool calibrated = false;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Spooky\") bool refining = false;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Spooky\") float quality = 0;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Spooky\") FString system1;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Spooky\") FString system2;\n};\n\n//Unreal engine interface layer linking to generic code from the fusion module\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass USpookyFusionPlant : public UActorComponent\n{\n\tGENERATED_BODY()\n\n\t//Fusionplant\n\tspooky::Core plant;\n\n\t//Input Skeletons\n\tstd::vector<USkeletalMeshComponent*> skeletons;\n\tstd::vector<Eigen::Matrix<float, 7, 1>> skeletonCovariances;\n\npublic:\t\n\n\t// Sets default values for this component's properties\n\tUSpookyFusionPlant();\n\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\t\n\t// Called every frame\n\tvirtual void TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction ) override;\n\n//===========================\n//Setup and initialisation\n//===========================\n\n\t//Add complete skeleton to list of fusion objects\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tvoid Configure(float input_units_m = 1, float output_units_m = 1);\n\n\t//Add complete skeleton to list of fusion objects\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tvoid AddSkeleton(USkeletalMeshComponent* skeletal_mesh, FVector position_var, FVector4 quaternion_var);\n\n\t//Set the output target which will have the complete fused skeleton pose applied\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tvoid AddOutputTarget(USkeletalMeshComponent* skeletal_mesh);\n\t\n\t//Perform some setup postprocessing\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tvoid FinaliseSetup();\n\n\t//Set the reference frame for the skeleton\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tvoid SetReferenceFrame(FString system_name);\n\n\n\n//TODO: Contruction of sensor nodes\n\n\t////Add a new sensor node model\n\t//UFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\t//void AddSensorNode(FString nodeName, FTransform initialState, FTransform initialCovariance);\n\n\t////Add a new sensor node model\n\t//UFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\t//void SetHomeCoordinateSpace(FString systemName);\n\n//===========================\n//Update functions\n//===========================\n\t//Add vec3 measurement\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tvoid AddPositionMeasurement(TArray<FString> nodeNames, FString systemName, int sensorID, float timestamp_sec, FVector measurement, FVector covariance, bool globalSpace = true, float confidence = 1);\n\t\n\t//Add rotation quaternion method\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tvoid AddRotationMeasurement(TArray<FString> nodeNames, FString systemName, int sensorID, float timestamp_sec, FRotator measurement, FVector4 covariance, bool globalSpace = true, float confidence = 1);\n\n\t//Add transform measurement in local space\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tvoid AddPoseMeasurement(TArray<FString> nodeNames, FString systemName, int sensorID, float timestamp_sec, FTransform measurement, FVector position_var, FVector4 quaternion_var, bool globalSpace = true, float confidence = 1);\n\n\t//Adds measurements for whole skeleton\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tvoid addSkeletonMeasurement(int skel_index);\n\n\t//Align, calibrate and fuse all added data\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tvoid Fuse();\n\n\t//Gets animation details for driving the skeleton\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tFTransform getBoneTransform(const FString& name);\n\n//===========================\n//Data retrieval functions\n//===========================\n\t//Gets the calibration result mapping T:s1->s2\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tFCalibrationResult getCalibrationResult(FString s1, FString s2);\n\t\n\t//Gets the name of the node which the specified sensor is attached to\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tFString getCorrelationResult(FString s1, int sensorID);\n\n\t//Gets the result of fusion for a node\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tFTransform getNodeGlobalPose(FString node);\n\n//===========================\n//Data saving/loading functions\n//===========================\n\n\t//Sets save/load location\t\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tvoid setSaveDirectory(FString dir);\n\n\t//Saves the calibration result mapping T:s1->s2\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tvoid saveCalibrationResult(FString s1, FString s2);\n\t\n\t//Loads the calibration result mapping T:s1->s2\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tvoid loadCalibrationResult(FString s1, FString s2);\n\t\n//===========================\n//Utility\n//===========================\n\n\t//Compute axis angle representation (x,y,z,alpha)\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tFVector4 getRotatorAxisAngle(FRotator R);\n\n\n\t//Method to copy data from one poseable mesh to another\n\tvoid CopyPose(UPoseableMeshComponent* target, const UPoseableMeshComponent* input);\n\n\t//Methods for creating measurements which can then be sent to the fusion plant\n\tspooky::Measurement::Ptr CreatePositionMeasurement(FString system_name, int sensorID, float timestamp_sec, FVector position, FVector uncertainty, float confidence = 1);\n\tspooky::Measurement::Ptr CreateRotationMeasurement(FString system_name, int sensorID, float timestamp_sec, FQuat rotation, FVector4 uncertainty, float confidence = 1);\n\tspooky::Measurement::Ptr CreateScaleMeasurement(FString system_name, int sensorID, float timestamp_sec, FVector scale, FVector uncertainty, float confidence = 1);\n\tspooky::Measurement::Ptr CreatePoseMeasurement(FString system_name, int sensorID, float timestamp_sec, FVector v, FQuat q, Eigen::Matrix<float,7,1> uncertainty, float confidence = 1);\n\t\n\t//Sets data common to all types of measurements\n\tvoid SetCommonMeasurementData(spooky::Measurement::Ptr& m, FString system_name, int sensorID, float timestamp_sec, float confidence);\n\n\t//Convert names to nodeDescriptors\n\tstd::vector<spooky::NodeDescriptor> convertToNodeDescriptors(const TArray<FString>& names);\n\n\t//Convert Transform3D to FMatrix\n\tFMatrix convert(const spooky::Transform3D& T);\n\tspooky::Transform3D convert(const FMatrix& T);\n//===========================\n//DEBUG\n//===========================\n\n\t//For testing blueprints: TODO delete\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tFString GetCalibrationStateSummary();\n\n\t//For testing blueprints: TODO delete\n\tUFUNCTION(BlueprintCallable, Category = \"Spooky\")\n\tFString GetCalibrationTimingSummary();\n\n};\n",
			"file": "Plugins/Spooky/Source/Spooky/Public/SpookyFusionPlant.h",
			"file_size": 8326,
			"file_write_time": 131528601591465850,
			"settings":
			{
				"buffer_size": 8122,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "// Created by Chance_07 2014\n#pragma once\n\n#include \"UnrealFusion.h\"\n#include \"Classes/Animation/AnimNodeBase.h\"\n#include \"AnimNode_TranslateWith.generated.h\"\n\n\nUSTRUCT()\nstruct FAnimNode_TranslateWith : public FAnimNode_Base\n{\n\tGENERATED_USTRUCT_BODY()\n\n\t\t/** Input link(Base Pose) **/\n\t\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Links)\n\t\tFComponentSpacePoseLink ComponentPose;\n\n\t/** Name of bone to control **/\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = SkeletalControl)\n\t\tFBoneReference TargetBone;\n\n\t/** Source Bone Name to get transform from **/\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = SkeletalControl)\n\t\tFBoneReference SourceBone;\n\n\t/** This is typically the FORWARD Axis, and is false by default **/\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = AxisLock, meta = (PinHiddenByDefault))\n\t\tbool bUpdateX;\n\n\t/** This is typically the SIDE-TO-SIDE Axis, and is false by default **/\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = AxisLock, meta = (PinHiddenByDefault))\n\t\tbool bUpdateY;\n\n\t/** This is typically the UP Axis, and is true by default **/\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = AxisLock, meta = (PinHiddenByDefault))\n\t\tbool bUpdateZ;\n\n\t/** Target Location in world space if LookAtBone is empty */\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = SkeletalControl)\n\t\tFVector AddtoOffset;\n\n\t/** Controls how much of the translation is blended to the target, default is 1 **/\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = SkeletalControl, meta = (PinShownByDefault))\n\t\tfloat BlendWeight;\npublic:\n\tFAnimNode_TranslateWith();\npublic:\n\t// FAnimNode_Base interface\n\tvirtual void Initialize(const FAnimationInitializeContext& Context) override;\n\tvirtual void CacheBones(const FAnimationCacheBonesContext & Context)  override;\n\tvirtual void Update(const FAnimationUpdateContext& Context) override;\n\tvirtual void EvaluateComponentSpace(FComponentSpacePoseContext& Output) override;\n\t// End of FAnimNode_RCAnimNode interface\nprotected:\n\t// initialize any bone references you have\n\tvirtual void InitializeBoneReferences(const FBoneContainer & RequiredBones);\n\t// return true if it is valid to Evaluate\n\tvirtual bool IsValidToEvaluate(const USkeleton * Skeleton, const FBoneContainer & RequiredBones);\n\t// Evaluate the new component-space transforms for the affected bones.\n\tvirtual void EvaluateBoneTransforms(USkeletalMeshComponent* SkelComp, const FBoneContainer & RequiredBones, FA2CSPose& MeshBases, TArray<FBoneTransform>& OutBoneTransforms);// {}\nprivate:\n\tFVector ModTargetLocationInCompSpace;\n\tFVector CurrentAddedOffset;\n\tFVector JointOffset;\n};",
			"file": "Source/UnrealFusion/AnimNode_TranslateWith.h",
			"file_size": 2712,
			"file_write_time": 131487171990855591,
			"settings":
			{
				"buffer_size": 2648,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "/*  This file is part of UnrealFusion, a sensor fusion plugin for VR in the Unreal Engine\n    Copyright (C) 2017 Jake Fountain\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n#include \"Spooky.h\"\n#include \"Core.h\"\n#include <chrono>\n\nnamespace spooky {\n\n\tvoid Core::addBoneNode(const NodeDescriptor & node, const NodeDescriptor & parent, const Transform3D& boneTransform)\n\t{\n\t\tskeleton.addNode(node, parent);\n\t\tskeleton.setBoneForNode(node, boneTransform);\n\t}\n\n\tvoid Core::addPoseNode(const NodeDescriptor & node, const NodeDescriptor & parent, const Transform3D& poseInitial)\n\t{\n\t\tskeleton.addNode(node, parent);\n\t\tskeleton.setPoseNode(node, poseInitial);\n\t}\n\n\tvoid Core::setReferenceSystem(const SystemDescriptor & system) {\n\t\tskeleton.setReferenceSystem(system);\n\t}\n\n\t// =================\n\t//Saving and loading\n\t// =================\n\tvoid Core::setSaveDirectory(const std::string& dir) {\n\t\tsaveManager.setWorkingDirectory(dir);\n\t}\n\n\tvoid Core::loadCalibration(const SystemDescriptor& s1, const SystemDescriptor& s2, bool tryReverse) {\n\t\tCalibrationResult cal(s1, s2);\n\t\t//TODO: if fail, try reverse order\n\t\tbool success = saveManager.load(&cal);\n\t\tif (success) {\n\t\t\tcalibrator.setResults(cal);\n\t\t\t//SPOOKY_LOG(\"Loaded Calibration[\" + s1.name + \", \" + s2.name + \"] SUCCESSFULLY\");\n\t\t}\n\t\telse {\n\t\t\tSPOOKY_LOG(\"Loading Calibration[\" + s1.name + \", \" + s2.name + \"] FAILED\");\n\t\t\tif(tryReverse){\n\t\t\t\tloadCalibration(s2,s1,false);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid Core::saveCalibration(const SystemDescriptor& s1, const SystemDescriptor& s2) {\n\t\tbool success = saveManager.save(calibrator.getResultsFor(s1, s2));\n\t\tif (success) {\n\t\t\t//SPOOKY_LOG(\"Saved Calibration[\" + s1.name + \", \" + s2.name + \"] SUCCESSFULLY\");\n\t\t}\n\t\telse {\n\t\t\tSPOOKY_LOG(\"Saving Calibration[\" + s1.name + \", \" + s2.name + \"] FAILED\");\n\t\t}\n\t}\n\n\n\t// =================\n\t//END: Saving and loading\n\t// =================\n\tvoid Core::finaliseSetup()\n\t{\n\t\tskeleton.enumerateHeirarchy();\n\t}\n\t//Adds a new measurement to the system\n\tvoid Core::addMeasurement(const Measurement::Ptr& m, const NodeDescriptor& node) {\n\t\tm->getSensor()->addNode(node);\n\t\tskeleton.addGenericNode(node);\n\t\tmeasurement_buffer.push_back(m);\n\t}\n\n\t//Adds a new measurement to the system\n\tvoid Core::addMeasurement(const Measurement::Ptr& m, const std::vector<NodeDescriptor>& nodes) {\n\t\t//Add nodes which the measurement might correspond to - actually gets stored in the sensor pointer\n\t\tfor(auto& n : nodes){\n\t\t\tm->getSensor()->addNode(n);\n\t\t\tskeleton.addGenericNode(n);\n\t\t}\n\t\tmeasurement_buffer.push_back(m);\n\t}\n\n\t//Computes data added since last fuse() call. Should be called repeatedly\t\n\tvoid Core::fuse() {\n\t\t//TODO: add ifdefs for profiling\n\t\t//Add new data to calibration, with checking for usefulness\n\t\tutility::profiler.startTimer(\"Correlator\");\n\t\tutility::profiler.startTimer(\"All\");\n\t\t//SPOOKY_LOG(\"Fusing: \" + std::to_string(measurement_buffer.size()) + \"measurements\");\n\n\t\tcorrelator.addMeasurementGroup(measurement_buffer);\n\t\tcorrelator.identify();\n\t\tutility::profiler.endTimer(\"Correlator\");\n\t\tif(correlator.isStable() || true){\n\t\t\tutility::profiler.startTimer(\"Calibrator add\");\n\t\t\tcalibrator.addMeasurementGroup(measurement_buffer);\n\t\t\tutility::profiler.endTimer(\"Calibrator add\");\n\t\t\tutility::profiler.startTimer(\"Calibrate\");\n\t\t\tcalibrator.calibrate();\n\t\t\tutility::profiler.endTimer(\"Calibrate\");\n\t\t\tif(calibrator.isStable() || true){\n\t\t\t\tutility::profiler.startTimer(\"Fuse\");\n\t\t\t\tskeleton.addMeasurementGroup(measurement_buffer);\n\t\t\t\tskeleton.fuse(calibrator);\n\t\t\t\tutility::profiler.endTimer(\"Fuse\");\n\t\t\t}\n\t\t}\t\n\t\tmeasurement_buffer.clear();\n\t\t//TODO: do this less often\n\t\tutility::profiler.endTimer(\"All\");\n\t}\n\n\tCalibrationResult Core::getCalibrationResult(SystemDescriptor s1, SystemDescriptor s2) {\n\t\treturn calibrator.getResultsFor(s1, s2);\n\t}\n\n\tTransform3D Core::getNodeGlobalPose(const NodeDescriptor& node){\n\t\treturn skeleton.getNodeGlobalPose(node);\n\t}\n\n\tTransform3D Core::getNodeLocalPose(const NodeDescriptor & node)\n\t{\n\t\treturn skeleton.getNodeLocalPose(node);\n\t}\n\n\tNodeDescriptor Core::getCorrelationResult(SystemDescriptor system, SensorID id) {\n\t\tif (sensors.count(system) > 0 &&\n\t\t\tsensors[system].count(id) > 0)\n\t\t{\n\t\t\treturn sensors[system][id]->getNode();\n\t\t}\n\t\telse {\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\t//Called by owner of the Core object\n\tvoid Core::setMeasurementSensorInfo(Measurement::Ptr & m, SystemDescriptor system, SensorID id)\n\t{\n\t\t//If we haven't seen this sensor already, initialise\n\t\tif (utility::safeAccess(sensors, system).count(id) == 0) {\n\t\t\tutility::safeAccess(sensors, system)[id] = std::make_unique<Sensor>();\n\t\t\tutility::safeAccess(sensors, system)[id]->system = system;\n\t\t\tutility::safeAccess(sensors, system)[id]->id = id;\n\t\t}\n\t\t//Set pointer in measurement\n\t\tm->setSensor(sensors[system][id]);\n\t}\n\n\tstd::string Core::getCalibratorStateSummary() {\n\t\treturn calibrator.getStateSummary();\n\t}\n\n\tstd::string Core::getTimingSummary() {\n\t\treturn utility::profiler.getReport();\n\t}\n}\n",
			"file": "Plugins/Spooky/Source/Spooky/Spooky/Core.cpp",
			"file_size": 5724,
			"file_write_time": 131491434076641408,
			"settings":
			{
				"buffer_size": 5555,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Plugins/Spooky/Intermediate/Build/Win64/UE4Editor/Inc/Spooky/Spooky.generated.cpp",
			"settings":
			{
				"buffer_size": 0,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "// Created by Chance_07 2014\n#include \"UnrealFusion.h\"\n#include \"Runtime/Engine/Classes/Animation/AnimInstance.h\"\n#include \"AnimNode_TranslateWith.h\"\n\nFAnimNode_TranslateWith::FAnimNode_TranslateWith()\n\t: FAnimNode_Base()\n\t, bUpdateX(false)// This is only to set\n\t, bUpdateY(false)// the defaults for the\n\t, bUpdateZ(true)// Axis pins (Can be changed in BP)\n\t, AddtoOffset(FVector::ZeroVector)\n{\n\tBlendWeight = 1;\n\tJointOffset.ZeroVector;\n\t// NULL so that it will be tested at least once\n\tCurrentAddedOffset.X = NULL;\n\tCurrentAddedOffset.Y = NULL;\n\tCurrentAddedOffset.Z = NULL;\n}\n\nvoid FAnimNode_TranslateWith::Initialize(const FAnimationInitializeContext& Context)\n{\n\tComponentPose.Initialize(Context);\n}\n\nvoid FAnimNode_TranslateWith::Update(const FAnimationUpdateContext& Context)\n{\n\tComponentPose.Update(Context);\n}\n\nvoid FAnimNode_TranslateWith::CacheBones(const FAnimationCacheBonesContext & Context)\n{\n\tInitializeBoneReferences(Context.AnimInstance->RequiredBones);\n\tComponentPose.CacheBones(Context);\n}\n\n//This is just a check to make sure that the bones are present\nvoid FAnimNode_TranslateWith::InitializeBoneReferences(const FBoneContainer & RequiredBones)\n{\n\t// Check the Source Bone\n\tif (SourceBone.Initialize(RequiredBones)) {}\n\telse\n\t{\n\t\tUE_LOG(LogAnimation, Warning, TEXT(\"No Source Bone found, please check input\"));\n\t}\n\n\t// Check the Target Bone\n\tif (TargetBone.Initialize(RequiredBones)) {}\n\telse\n\t{\n\t\tUE_LOG(LogAnimation, Warning, TEXT(\"No Target Bone found, please check input\"));\n\t}\n}\n\n//This Checks for Updates, if no Axis is checked, returns Base Pose and moves on\nvoid FAnimNode_TranslateWith::EvaluateComponentSpace(FComponentSpacePoseContext& Output)\n{\n\t// Evaluate the input\n\tComponentPose.EvaluateComponentSpace(Output);\n\n\n\t// If any Axis is checked, and both bones are present, then we will continue\n\tif (((bUpdateX) || (bUpdateY) || (bUpdateZ)) && IsValidToEvaluate(Output.AnimInstance->CurrentSkeleton, Output.AnimInstance->RequiredBones))\n\t{\n\t\tUSkeletalMeshComponent* Component = Output.AnimInstance->GetSkelMeshComponent();\n\t\tTArray<FBoneTransform> BoneTransforms;\n\t\t//EvaluateBoneTransforms(Component, Output.AnimInstance->RequiredBones, Output.Pose, BoneTransforms);\n\n\t\tcheckSlow(!ContainsNaN(BoneTransforms));\n\n\t\tif (BoneTransforms.Num() > 0)\n\t\t{\n\t\t\tOutput.Pose.LocalBlendCSBoneTransforms(BoneTransforms, BlendWeight);\n\t\t}\n\t}\n}\n\n//This Evaluates the bones, and transforms\t\nvoid FAnimNode_TranslateWith::EvaluateBoneTransforms(USkeletalMeshComponent* SkelComp, const FBoneContainer & RequiredBones, FA2CSPose& MeshBases, TArray<FBoneTransform>& OutBoneTransforms)\n{\n\tcheck(OutBoneTransforms.Num() == 0);\n\n\t// Component Space Transforms used to modify Target Bone\n\tFTransform SourceBoneTM = MeshBases.GetComponentSpaceTransform(SourceBone.BoneIndex);\n\tFTransform TargetBoneTM = MeshBases.GetComponentSpaceTransform(TargetBone.BoneIndex);\n\n\t// If any changes have occured, add them, and reset offset\n\tif (!(CurrentAddedOffset == AddtoOffset))\n\t{\n\t\tCurrentAddedOffset = SkelComp->ComponentToWorld.InverseTransformPosition(AddtoOffset);\n\t\tJointOffset.Set((NULL), (NULL), (NULL));\n\t}\n\n\tif ((JointOffset.X == NULL) || (JointOffset.Y == NULL) || (JointOffset.Z == NULL))// If no Axis are checked, no need to do anything\n\t{\n\t\t// These are based on the Base Pose location and used to create the default offset\n\t\tFVector tempSourceOffset;\n\t\tFVector tempTargetOffset;\n\n\t\t// Get the Base Pose of the Source Bone\n\t\ttempSourceOffset.Set((SourceBoneTM.GetLocation().X), (SourceBoneTM.GetLocation().Y), (SourceBoneTM.GetLocation().Z));\n\n\t\t// Get the Base Pose of the Target Bone\n\t\ttempTargetOffset.Set((TargetBoneTM.GetLocation().X), (TargetBoneTM.GetLocation().Y), (TargetBoneTM.GetLocation().Z));\n\n\t\t// Get the Starting Offset from ALL inputs\n\t\tJointOffset.Set((tempTargetOffset.X - tempSourceOffset.X + CurrentAddedOffset.X), (tempTargetOffset.Y - tempSourceOffset.Y + CurrentAddedOffset.Y), (tempTargetOffset.Z - tempSourceOffset.Z + CurrentAddedOffset.Z));\n\n\t\t// Assign Offset to Mod Target Location\n\t\tModTargetLocationInCompSpace.Set((tempTargetOffset.X), (tempTargetOffset.Y), (tempTargetOffset.Z));\n\n\n\t}\n\t//need to add a multiplier control so that you can control how much of the source movement is translated to the target(I.E. BlendEffects)\n\tif (bUpdateX)//Update X if checked\n\t{\n\t\tModTargetLocationInCompSpace.X = ((SourceBoneTM.GetTranslation().X) + JointOffset.X);//SourceTM + Offset\n\t}\n\tif (bUpdateY)//Update Y if checked\n\t{\n\t\tModTargetLocationInCompSpace.Y = ((SourceBoneTM.GetTranslation().Y) + JointOffset.Y);\n\t}\n\tif (bUpdateZ)//Update Z if checked\n\t{\n\t\tModTargetLocationInCompSpace.Z = ((SourceBoneTM.GetTranslation().Z) + JointOffset.Z); //(SourceBoneTM.GetTranslation().Z);\n\t}\n\t//Set the Targets Transform and pass out to Output(End of tick)\n\tTargetBoneTM.SetTranslation(ModTargetLocationInCompSpace);\n\n\t// Returns to caller with new location\n\t//OutBoneTransforms.Add(FBoneTransform(TargetBone.BoneIndex, TargetBoneTM));\n}\n\n// Makes sure that both bones are valid\nbool FAnimNode_TranslateWith::IsValidToEvaluate(const USkeleton * Skeleton, const FBoneContainer & RequiredBones)\n{\n\t// if both bones are valid\n\treturn (TargetBone.IsValid(RequiredBones) && (SourceBone.IsValid(RequiredBones)));\n}",
			"file": "Source/UnrealFusion/AnimNode_TranslateWith.cpp",
			"file_size": 5371,
			"file_write_time": 131487171990805519,
			"settings":
			{
				"buffer_size": 5233,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 196.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 464.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Webcamera",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion",
		"/C/Users/NUbots/Documents/Unreal Projects/RahsToolSuite_Root",
		"/C/Users/NUbots/Documents/Unreal Projects/RahsToolSuite_Root/Plugins",
		"/C/Users/NUbots/Documents/Unreal Projects/RahsToolSuite_Root/Plugins/RahsToolSuite"
	],
	"file_history":
	[
		"/D/Kinect_VR.spky",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Saved/Autosaves/Game/Fusion/Fusion_Blueprint2_Auto3.uasset",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Private/AnimGraphNode_GetSpookyResult.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Private/AnimNode_GetSpookyResult.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Public/AnimGraphNode_GetSpookyResult.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Public/AnimNode_GetSpookyResult.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Public/Logging.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/ArticulatedModel.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Calibration.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/CalibrationProcedures.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Core.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/CorrelationProcedures.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Correlator.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/FusionTypes.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/FusionTypes.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/SaveManager.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Utilities/CalibrationUtilities.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Utilities/CommonMath.h",
		"/C/Users/NUbots/Documents/Unreal Projects/RahsToolSuite_Root/Plugins/RahsToolSuite/RahsToolSuite.uplugin",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/PerceptionNeuron/Source/PerceptionNeuronEditor/PerceptionNeuronEditor.Build.cs",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/PerceptionNeuron/Source/PerceptionNeuronEditor/Public/AnimGraphNode_NewPoseCalc.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/PerceptionNeuron/Source/PerceptionNeuronRuntime/Public/AnimNode_NewPoseCalc.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/PerceptionNeuron/Source/PerceptionNeuronRuntime/Public/BoneMappingInfo.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Private/SpookyFusionPlant.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Public/SpookyFusionPlant.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Private/AnimGraphNode_GetSpookyResult.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/ArticulatedModel.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Articulation.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Articulation.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Calibration.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Core.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Correlator.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/SaveManager.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Utilities/Conventions.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Utilities/CorrelationUtilities.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Utilities/DataStructures.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Spooky/Utilities/TimeProfiling.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/sophus/example_ensure_handler.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/ArticulatedModel.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/FusionPlant.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/Correlator.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/Calibration.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Private/FusionPlant.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/Spooky/Source/Spooky/Public/FusionPlant.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Logging.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/UnrealFusion.Build.cs",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/.gitignore",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/Core.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/FusionPlant.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/FusionTypes.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/CalibrationProcedures.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/Correlator.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/Calibration.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/Articulation.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/experiment_analysis.py",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment2/Rift/FreeMovement/1_messed_up",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment2/Rift/FreeMovement/1_bad_tracking",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment2/Rift/FreeMovement/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment2/Rift/Shooting/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment2/Rift/Sorting/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment2/Vive/FreeMovement/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment2/Vive/Shooting/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment2/Vive/Sorting/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment3/Vive/FreeMovement/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment3/Vive/Shooting/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/TraceExperimentWalkingBlackPants/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/TraceExperiment/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment3/Vive/Sorting/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment1/Rift/Shooting/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment1/Rift/Sorting/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/CustomMovementRift1/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/CustomMovementLongGripRiftLitMethod1/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/Experiment1/Rift/FreeMovement/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ExperimentVRST2017/CustomMovementLongGripRift1/1",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/Articulation.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/Core.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/ArticulatedModel.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/Utilities/DataStructures.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/FusionTypes.cpp",
		"/C/Users/NUbots/spooky_calibrations/Optitrack_VR.spky",
		"/C/Users/NUbots/spooky_calibrations/Kinect_VR.spky",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/SaveManager.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/SaveManager.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/Utilities/CalibrationUtilities.h",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/README.md",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/easywsclient.hpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Plugins/JSONQuery/JSONQuery.uplugin",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/FusionTesting/CalibrationTests.cpp",
		"/C/Users/NUbots/Code/NUbots/shared/utility/autocal/CalibrationTools.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Fusion/Utilities/CommonMath.h",
		"/C/Users/NUbots/Code/easywsclient-master/example-client.cpp",
		"/C/Users/NUbots/Code/easywsclient-master/example-client-cpp11.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/easywsclient.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/example_FK_data.json",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/optitrack.py",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/optitrack_data.csv",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/ground_truth_analysis.py",
		"/C/Users/NUbots/Code/fusionkit-master/doc/WebsocketExample/wstest.html",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Source/UnrealFusion/Websocket.cpp",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/data_analysis.py",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/point_clouds.csv",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/Spericaldata.csv",
		"/C/Users/NUbots/Code/easywsclient-master/Makefile",
		"/C/Users/NUbots/Code/fusionkit-master/doc/WebsocketExample/server.js",
		"/C/Program Files (x86)/FusionKitStudio/Studio.exe.config",
		"/C/Users/NUbots/Code/FusionKit/fusionkit_websocket_example.html",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/LHR-FFCDFF41_1494999405_01.pb",
		"/D/Epic Games/4.14/Engine/Plugins/OptiTrack/OptitrackNatnet/OptitrackNatnet.uplugin",
		"/C/Users/NUbots/Downloads/scatter3d_demo.py",
		"/C/Users/NUbots/Documents/Unreal Projects/UnrealFusion/Analysis/result1.csv",
		"/C/Program Files (x86)/Microsoft Visual Studio 14.0/Common7/Packages/Debugger/autoexp.dat",
		"/C/Users/User/autoexp_backup.dat",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/CorrelationProcedures.cpp",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/FusionTypes.cpp",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/Utilities/CorrelationUtilities.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/Calibration.cpp",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/FusionTypes.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/Calibration.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/Core.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/FusionGraph.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/FusionGraph.cpp",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Eigen/src/Cholesky/LDLT.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/DataAnalysisModule.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/DataAnalysisModule.cpp",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/Correlator.h",
		"/C/Users/User/Code/UnrealFusion/.gitignore",
		"/C/Users/User/Code/UnrealFusion/README.md",
		"/C/Users/User/Code/DeepLearningRenderer/scripts/addons/blender/DeepLearningRenderer/geometry.py"
	],
	"find":
	{
		"height": 40.0
	},
	"find_in_files":
	{
		"height": 138.0,
		"where_history":
		[
			"C:\\Users\\NUbots\\Documents\\Unreal Projects\\UnrealFusion\\Source\\UnrealFusion",
			"C:\\Users\\NUbots\\Documents\\Unreal Projects\\UnrealFusion\\Plugins\\Spooky",
			"C:\\Users\\NUbots\\Documents\\Unreal Projects\\UnrealFusion\\",
			"C:\\Users\\NUbots\\Documents\\Unreal Projects\\UnrealFusion\n",
			"C:\\Users\\NUbots\\Documents\\Unreal Projects\\UnrealFusion\\Plugins\\Spooky\\Source\\Spooky\\Spooky",
			"C:\\Users\\NUbots\\Documents\\Unreal Projects\\UnrealFusion\\Plugins\\Spooky\\Source\\Spooky",
			"C:\\Users\\NUbots\\Documents\\Unreal Projects\\UnrealFusion\\Plugins\\Spooky\\Source\\Spooky\\Spooky",
			"C:\\Users\\NUbots\\Documents\\Unreal Projects\\UnrealFusion\\Plugins\\Spooky\\Source\\Spooky\\sophus",
			"C:\\Users\\NUbots\\Documents\\Unreal Projects\\UnrealFusion\\Plugins\\Spooky\\Source\\Spooky\\Spooky",
			"C:\\Users\\NUbots\\Documents\\Unreal Projects\\UnrealFusion\\Source",
			"",
			"D:\\Epic Games\\4.14\\Engine\\Plugins\\OptiTrack",
			"C:\\Users\\User\\Code\\UnrealFusion\\Source\\UnrealFusion\\Fusion",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"USkeletalMesh",
			"poseable_mesh",
			");\n",
			"FAnimNode_GetSpookyResult",
			"SPOOKY_LOG(\"TEST FLOAT = \" + std::to_string(testFloat));",
			"FUSION_LOG",
			"SPOOKY_SCREEN_MESSAGE",
			"FUSION_LOG",
			"/../../../../../../../../../../../../../../../.",
			"override",
			"\"Fusion\"",
			"Fusion",
			"namespace fusion",
			"fusion::",
			"UFusionPlant",
			"#include \"Fusion/Utilities",
			"//#include \"UnrealFusion.h\"",
			"#include \"UnrealFusion.h\"",
			"config",
			"(ambiguous_threshold)|(elimination_threshold)|(diff_threshold)",
			"qualityScaleFactor",
			"(initial_quality_threshold)|(quality_convergence_threshold)|(fault_hysteresis_rate)|(relevance_decay_rate)|(settle_threshold)|(fault_angle_threshold)|(fault_distance_threshold)",
			"DO: make these some logical values\n\t\t\t//TODO: make this different for each system pair\n\t\t\tfloat initial_quality_threshold = 0.5;\n\t\t\tfloat quality_convergence_threshold = 0.01;\n\t\t\tfloat fault_hysteresis_rate = 0.25;\n\t\t\tfloat relevance_decay_rate = 0.1;\n\t\t\tfloat settle_threshold = 0.90;\n\t\t\tfloat fault_angle_threshold = M_PI * 5 / 180;\n\t\t\tfloa",
			"(diff_threshold)|(min_count_per_node)|(count_threshold)",
			"data*",
			"[1-9]",
			"(ambiguous_threshold)|(elimination_threshold)|(diff_threshold)",
			"(ambiguous_threshold)|\n(elimination_threshold)|\n(diff_threshold)",
			";\n",
			"Config",
			"poseable_mesh",
			"UPoseable",
			"UPoseableMeshComponent",
			"CopyPose",
			"101953",
			"145757",
			"SpookyTestShooting_C_0",
			"SpookyTestSorting_C_1",
			"14229",
			"SpookyFusion_C_0",
			"SpookyTestSorting_C_1",
			"113447",
			"113318",
			"SpookyTestShooting_C_0",
			"Rift",
			"SpookyFusion_C_1",
			"104528",
			"SpookyTestSorting_C_1",
			"SpookyTestShooting_C_0",
			"SpookyFusion_C_0",
			"2017_6_19_0_0",
			"Calibration Result:) ",
			"Calibration Result:)",
			"2017_6_18_0_0",
			"REFINEMENT FINISHED!!!",
			"REFINEMENT",
			"Early EndPlayMap Detection: Level ",
			"EndPlayMap",
			"2017_6_18_0_0",
			"75",
			"0.9",
			"2017_6_18_0_0",
			"utility::profiler",
			"MultiStream",
			"calibrationSet",
			"clear_count",
			"clears_left",
			"Sensor",
			"totalCount",
			"maxCount",
			"m->getNode()",
			"homePose",
			"getGlobalPose",
			"utility::profiler",
			"result.relevance",
			"result.relevance ",
			"result.relevance",
			"result",
			"Result",
			"Eigen::Matrix4f",
			"m2_out.",
			"m1_out",
			"pos2",
			"pos1",
			"Starting over",
			"Already calibrated - watching for faults",
			"LogTemp:Warning: FUSION LOG : DATA[Kinect, VR]",
			"LogTemp:Warning: FUSION LOG : DATA[Kinect, Optitrack]",
			"Performed",
			"FUSION",
			"FUSION_LOG",
			"FUSION_SCREEN_MESSAGE",
			"FUSION_LOG",
			"result.quality",
			"LogTemp:Warning:",
			"dummy +",
			"to_string",
			"CalibrationResult",
			"current",
			"currentResult",
			"skel",
			"fprintf",
			"fputs",
			"setTimeout",
			"articulations[0].getType()",
			"getMeanTransform",
			"plant",
			"skeletonCovariances",
			"skeletons",
			"config.units",
			"Eigen::Quaternionf",
			"Eigen::Quaternion4f",
			"Eigen::Quaternion4f ",
			"Matrix3f",
			"Rotation3D",
			"Matrix4f",
			"F",
			"Vector3f",
			"arma::vec",
			"arma::mat",
			"Transform3D",
			"arma::vec3",
			"arma::mat",
			"arma::vec",
			"rotation",
			"result",
			"version",
			"4.14"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"SPOOKY_LOG",
			"namespace spooky",
			"spooky::",
			"USpookyFusionPlant",
			"#include \"Utilities",
			"#include \"Spooky.h\"",
			"//#include \"UnrealFusion.h\""
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 8,
			"sheets":
			[
				{
					"buffer": 0,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1410,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										258,
										268
									],
									[
										497,
										507
									],
									[
										793,
										803
									],
									[
										945,
										955
									],
									[
										1047,
										1057
									],
									[
										1157,
										1167
									],
									[
										1316,
										1326
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								822,
								822
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										821,
										822
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/curly_bracket.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										783,
										784
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content"
							],
							"detect_indentation": false,
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"line_numbers": false,
							"output_tag": 1,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "Plugins/Spooky/Source/Spooky/Private/SpookyFusionPlant.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16972,
						"regions":
						{
						},
						"selection":
						[
							[
								3989,
								3989
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										4903,
										4904
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/curly_bracket.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										3921,
										3922
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1035.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/C/Users/NUbots/Mining/mine.bat",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 257,
						"regions":
						{
						},
						"selection":
						[
							[
								33,
								33
							]
						],
						"settings":
						{
							"auto_name": "",
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/Batch File/Batch File.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/C/Users/NUbots/AppData/Local/Temp/7zOCF315FAF/README.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 994,
						"regions":
						{
						},
						"selection":
						[
							[
								471,
								471
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/Markdown/Markdown.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "Plugins/Webcamera/Source/Public/IWebcamera.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2271,
						"regions":
						{
						},
						"selection":
						[
							[
								1549,
								1549
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										2268,
										2269
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/curly_bracket.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										249,
										250
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 5,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 36,
						"regions":
						{
						},
						"selection":
						[
							[
								36,
								36
							]
						],
						"settings":
						{
							"auto_name": "Get rid of:",
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "Source/UnrealFusion/easywsclient.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20294,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "Source/UnrealFusion/Websocket.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1684,
						"regions":
						{
						},
						"selection":
						[
							[
								762,
								762
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										1167,
										1168
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/curly_bracket.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										710,
										711
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": ".gitignore",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 503,
						"regions":
						{
						},
						"selection":
						[
							[
								502,
								502
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": ".git/config",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 641,
						"regions":
						{
						},
						"selection":
						[
							[
								376,
								376
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "UnrealFusion.uproject",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 760,
						"regions":
						{
						},
						"selection":
						[
							[
								328,
								328
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 135.0,
						"zoom_level": 1.0
					},
					"stack_index": 16,
					"type": "text"
				}
			]
		},
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 1,
					"file": "Plugins/Spooky/Source/Spooky/Private/SpookyFusionPlant.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16972,
						"regions":
						{
						},
						"selection":
						[
							[
								926,
								926
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										4903,
										4904
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/curly_bracket.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										3921,
										3922
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "Plugins/Spooky/Source/Spooky/Public/SpookyFusionPlant.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8122,
						"regions":
						{
						},
						"selection":
						[
							[
								2975,
								2975
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
									"1":
									[
										1977,
										1978
									]
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 855.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				}
			]
		},
		{
			"sheets":
			[
				{
					"buffer": 12,
					"file": "Source/UnrealFusion/AnimNode_TranslateWith.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2648,
						"regions":
						{
						},
						"selection":
						[
							[
								860,
								860
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										2646,
										2647
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/curly_bracket.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										226,
										227
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 135.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "Plugins/Spooky/Source/Spooky/Spooky/Core.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5555,
						"regions":
						{
						},
						"selection":
						[
							[
								2531,
								2531
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										2540,
										2541
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/curly_bracket.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										2504,
										2505
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 900.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "Plugins/Spooky/Intermediate/Build/Win64/UE4Editor/Inc/Spooky/Spooky.generated.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 0,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
									"1":
									[
										5200,
										5201
									]
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 15,
					"file": "Source/UnrealFusion/AnimNode_TranslateWith.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5233,
						"regions":
						{
						},
						"selection":
						[
							[
								785,
								785
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										818,
										819
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/curly_bracket.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										784,
										785
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content"
							],
							"glslvalidator_configured": true,
							"glslvalidator_enabled": 1,
							"history_list_is_closing": true,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 945.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 43.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			],
			[
				0,
				1,
				1,
				2
			],
			[
				1,
				1,
				2,
				2
			]
		],
		"cols":
		[
			0.0,
			0.554189435337,
			1.0
		],
		"rows":
		[
			0.0,
			0.694007490637,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 412.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "unrealfusion.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"gitig",
				"UnrealFusion\\.gitignore"
			],
			[
				"core",
				"UnrealFusion\\Plugins\\Spooky\\Source\\Spooky\\Spooky\\Core.cpp"
			],
			[
				"spookyfuh",
				"UnrealFusion\\Plugins\\Spooky\\Source\\Spooky\\Public\\SpookyFusionPlant.h"
			],
			[
				"fusionplant",
				"UnrealFusion\\Plugins\\Spooky\\Source\\Spooky\\Private\\SpookyFusionPlant.cpp"
			],
			[
				"fusionpla",
				"UnrealFusion\\Saved\\Autosaves\\Game\\Fusion\\Fusion_Blueprint2_Auto3.uasset"
			],
			[
				"animgraph",
				"UnrealFusion\\Plugins\\Spooky\\Source\\Spooky\\Public\\AnimGraphNode_GetSpookyResult.h"
			],
			[
				"animgranode",
				"UnrealFusion\\Plugins\\Spooky\\Source\\Spooky\\Private\\AnimGraphNode_GetSpookyResult.cpp"
			],
			[
				"spookyg",
				"UnrealFusion\\Plugins\\Spooky\\Intermediate\\Build\\Win64\\UE4Editor\\Inc\\Spooky\\Spooky.generated.cpp"
			],
			[
				"animnodesp",
				"UnrealFusion\\Plugins\\Spooky\\Source\\Spooky\\Public\\AnimNode_GetSpookyResult.h"
			],
			[
				"fusiologgi",
				"Source\\UnrealFusion\\Logging.h"
			],
			[
				"articulated",
				"Source\\UnrealFusion\\Fusion\\ArticulatedModel.h"
			],
			[
				"calibrationpro",
				"Source\\UnrealFusion\\Fusion\\CalibrationProcedures.cpp"
			],
			[
				"calibrationpo",
				"Source\\UnrealFusion\\Fusion\\CalibrationProcedures.cpp"
			],
			[
				"calibration.cpp",
				"Source\\UnrealFusion\\Fusion\\Calibration.cpp"
			],
			[
				"calibration",
				"Source\\UnrealFusion\\Fusion\\Calibration.h"
			],
			[
				"correl",
				"Source\\UnrealFusion\\Fusion\\Correlator.h"
			],
			[
				"corre",
				"Source\\UnrealFusion\\Fusion\\Correlator.cpp"
			],
			[
				"fusionty",
				"Source\\UnrealFusion\\Fusion\\FusionTypes.h"
			],
			[
				"fusplah",
				"Source\\UnrealFusion\\FusionPlant.h"
			],
			[
				"ana",
				"Analysis\\ExperimentVRST2017\\experiment_analysis.py"
			],
			[
				"fusionplan",
				"Source\\UnrealFusion\\FusionPlant.cpp"
			],
			[
				"core.h",
				"Source\\UnrealFusion\\Fusion\\Core.h"
			],
			[
				"core.c",
				"Source\\UnrealFusion\\Fusion\\Core.cpp"
			],
			[
				"artch",
				"Source\\UnrealFusion\\Fusion\\ArticulatedModel.h"
			],
			[
				"arti",
				"Source\\UnrealFusion\\Fusion\\ArticulatedModel.cpp"
			],
			[
				"datast",
				"Source\\UnrealFusion\\Fusion\\Utilities\\DataStructures.h"
			],
			[
				"art",
				"Source\\UnrealFusion\\Fusion\\ArticulatedModel.cpp"
			],
			[
				"core.cp",
				"Source\\UnrealFusion\\Fusion\\Core.cpp"
			],
			[
				"fusiontcpp",
				"Source\\UnrealFusion\\Fusion\\FusionTypes.cpp"
			],
			[
				"calibrationproced",
				"Source\\UnrealFusion\\Fusion\\CalibrationProcedures.cpp"
			],
			[
				"calibrati",
				"Source\\UnrealFusion\\Fusion\\Calibration.cpp"
			],
			[
				"calibratin",
				"Source\\UnrealFusion\\Fusion\\Calibration.h"
			],
			[
				"calibrationpr",
				"Source\\UnrealFusion\\Fusion\\CalibrationProcedures.cpp"
			],
			[
				"calibratip",
				"Source\\UnrealFusion\\Fusion\\CalibrationProcedures.cpp"
			],
			[
				"corh",
				"Source\\UnrealFusion\\Fusion\\Core.h"
			],
			[
				"calut",
				"Source\\UnrealFusion\\Fusion\\Utilities\\CalibrationUtilities.h"
			],
			[
				".giti",
				".gitignore"
			],
			[
				"fusintypes",
				"Source\\UnrealFusion\\Fusion\\FusionTypes.h"
			],
			[
				"webso",
				"Source\\UnrealFusion\\Websocket.cpp"
			],
			[
				"articu",
				"Source\\UnrealFusion\\Fusion\\ArticulatedModel.cpp"
			],
			[
				"common",
				"Source\\UnrealFusion\\Fusion\\Utilities\\CommonMath.h"
			],
			[
				"calibrau",
				"Source\\UnrealFusion\\Fusion\\Utilities\\CalibrationUtilities.h"
			],
			[
				"point",
				"Analysis\\point_clouds.csv"
			],
			[
				"sper",
				"Analysis\\Spericaldata.csv"
			],
			[
				"commonma",
				"Source\\UnrealFusion\\Fusion\\Utilities\\CommonMath.h"
			],
			[
				"fusiontypes",
				"Source\\UnrealFusion\\Fusion\\FusionTypes.h"
			],
			[
				"gun",
				"Assets\\Scripts\\Gun.cs"
			],
			[
				"cra",
				"Assets\\Scripts\\CrazyCube.cs"
			],
			[
				"hand",
				"Assets\\Scripts\\Hand.cs"
			],
			[
				"inp",
				"Assets\\Scripts\\ObjectInput.cs"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 364.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}

{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"unambiguous",
				"unambiguous_measurements"
			],
			[
				"ambiguous",
				"ambiguous_measurements"
			],
			[
				"addMeas",
				"addMeasurementGroup"
			],
			[
				"measurement",
				"measurement_buffer"
			],
			[
				"is",
				"isAmbiguous"
			],
			[
				"parent",
				"parent_desc"
			],
			[
				"Bound",
				"BoundingBox"
			],
			[
				"bound",
				"bounding_box"
			],
			[
				"image",
				"image_file_path"
			],
			[
				"proj",
				"proj_co"
			],
			[
				"vert",
				"vert_array"
			],
			[
				"current",
				"currentCamera"
			],
			[
				"Touch",
				"TouchStates"
			]
		]
	},
	"buffers":
	[
		{
			"file": "Source/UnrealFusion/Fusion/Core.cpp",
			"settings":
			{
				"buffer_size": 4109,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "Source/UnrealFusion/FusionPlant.cpp",
			"settings":
			{
				"buffer_size": 14041,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Source/UnrealFusion/Fusion/Correlator.h",
			"settings":
			{
				"buffer_size": 5571,
				"line_ending": "Windows"
			}
		},
		{
			"file": "FusionTesting/CalibrationTests.cpp",
			"settings":
			{
				"buffer_size": 2591,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "; AutoExp.Dat - templates for automatically expanding data\n; Copyright(c) Microsoft Corporation. All Rights Reserved.\n;---------------------------------------------------------------\n;\n; While debugging, Data Tips and items in the Watch and Variable\n; windows are automatically expanded to show their most important\n; elements. The expansion follows the format given by the rules\n; in this file. You can add rules for your types or change the\n; predefined rules.\n;\n; For good examples, read the rules in this file.\n;\n; To find what the debugger considers the type of a variable to\n; be, add it to the Watch window and look at the Type column.\n;\n; An AutoExpand rule is a line with the name of a type, an equals\n; sign, and text with replaceable parts in angle brackets. The\n; part in angle brackets names a member of the type and an\n; optional Watch format specifier.\n;\n; AutoExpand rules use the following syntax. The equals sign (=),\n; angle brackets (<>), and comma are taken literally. Square\n; brackets ([]) indicate optional items.\n;\n; type=[text]<member[,format]>...\n;\n; type\t\tName of the type (may be followed by <*> for template\n;\t\t\ttypes such as the ATL types listed below).\n;\n; text\t\tAny text.Usually the name of the member to display,\n;\t\t\tor a shorthand name for the member.\n;\n; member\tName of a member to display.\n;\n; format\tWatch format specifier. One of the following:\n;\n;\tLetter\tDescription\t\t\t\t\tSample\t\t   Display\n;\t------\t--------------------------\t------------   -------------\n;\td,i\t\tSigned decimal integer\t\t0xF000F065,d   -268373915\n;\tu\t\tUnsigned decimal integer\t0x0065,u\t   101\n;\to\t\tUnsigned octal integer\t\t0xF065,o\t   0170145\n;\tx,X\t\tHexadecimal integer\t\t\t61541,X\t\t   0X0000F065\n;\tl,h\t\tlong or short prefix for\t00406042,hx    0x0c22\n;\t\t\t  d, i, u, o, x, X\n;\tf\t\tSigned floating-point\t\t3./2.,f\t\t   1.500000\n;\te\t\tSigned scientific-notation\t3./2.,e\t\t   1.500000e+000\n;\tg\t\tShorter of e and f\t\t\t3./2.,g\t\t   1.5\n;\tc\t\tSingle character\t\t\t0x0065,c\t   'e'\n;\ts\t\tZero-terminated string\t\tpVar,s\t\t   \"Hello world\"\n;\tsu\t\tUnicode string\t\t\t\tpVar,su\t\t   \"Hello world\"\n;\n; For details of other format specifiers see Help under:\n; \"format specifiers/watch variable\"\n;\n; The special format <,t> specifies the name of the most-derived\n; type of the object. This is especially useful with pointers or\n; references to a base class.\n;\n; If there is no rule for a class, the base classes are checked for\n; a matching rule.\n;\n; There are some special entries allowed in the AutoExpand section:\n; $BUILTIN is used to display more complex types that need to do more\n; than just show a member variable or two.\n; $ADDIN allows external DLLs to be added to display even more complex\n; types via the EE Add-in API. The first argument is the DLL name, the\n; second argument is the name of the export from the DLL to use. For\n; further information on this API see the sample called EEAddIn.\n;\n; WARNING: if hexadecimal mode is on in the watch window, all numbers here are\n; evaluated in hex, e.g. 42 becomes 0x42\n\n[AutoExpand]\n\n; from windef.h\ntagPOINT =x=<x> y=<y>\ntagRECT =top=<top> bottom=<bottom> left=<left> right=<right>\n\n; from winuser.h\ntagMSG =msg=<message,x> wp=<wParam,x> lp=<lParam,x>\n\n; intrinsics\n__m64 =<m64_i64,x>\n__m128=$BUILTIN(M128)\n__m128i=$BUILTIN(M128I)\n__m128d=$BUILTIN(M128D)\n\n; from afxwin.h\nCDC =hDC=<m_hDC> attrib=<m_hAttribDC>\nCPaintDC =<,t> hWnd=<m_hWnd>\nCPoint =x=<x> y=<y>\nCRect =top=<top> bottom=<bottom> left=<left> right=<right>\nCSize =cx=<cx> cy=<cy>\nCWnd =<,t> hWnd=<m_hWnd>\nCWinApp =<,t> <m_pszAppName,s>\nCWinThread =<,t> h=<m_hThread> proc=<m_pfnThreadProc>\n\n; from afxcoll.h\nCPtrList =cnt=<m_nCount>\n\n; from afxstat_.h\nCProcessLocalObject =<,t>\nCThreadLocalObject =<,t>\n\n; from afx.h\nCArchiveException =cause=<m_cause>\nCFile =hFile=<m_hFile> name=<m_strFileName.m_pchData,s>\nCFileException =cause=<m_cause> OS Error=m_lOsError\nCMemFile =pos=<m_nPosition> size=<m_nFileSize>\nCObject =<,t>\nCRuntimeClass =<m_lpszClassName,s>\nCStdioFile =FILE*=<m_pStream> name=<m_strFilename.m_pchData,s>\nCTimeSpan =time=<m_time>\nCTime =time=<m_time>\n\n; from afxcoll.h\nCByteArray =count=<m_nCount>\nCStringList =count=<m_nCount>\n; same for all CXXXArray classes\n; same for CXXXList\n; same for CMapXXToXX\n\n; various string classes from MFC & ATL\n\n_com_error=<m_hresult,hr>\n_bstr_t=<m_Data->m_wstr,su> (<m_Data->m_RefCount,u>)\n_com_ptr_t<*>=<m_pInterface>\n_LARGE_INTEGER=<QuadPart>\n_ULARGE_INTEGER=<QuadPart>\nATL::CComPtr<*>=<p>\n\nATL::CComQIPtr<*>=<p>\n\ntagVARIANT=$BUILTIN(VARIANT)\nVARIANT=$BUILTIN(VARIANT)\n_GUID=$BUILTIN(GUID)\n\n; see EEAddIn sample for how to use these\n;_SYSTEMTIME=$ADDIN(EEAddIn.dll,AddIn_SystemTime)\n;_FILETIME=$ADDIN(EEAddIn.dll,AddIn_FileTime)\n\n[Visualizer]\n\n; Fixed size 4-vectors\nEigen::Matrix<*,4,1,*,*,*>|Eigen::Matrix<*,1,4,*,*,*>{\n   children\n   (\n      #(\n        [internals]: [$c,!],\n         x : ($c.m_storage.m_data.array)[0],\n         y : ($c.m_storage.m_data.array)[1],\n         z : ($c.m_storage.m_data.array)[2],\n         w : ($c.m_storage.m_data.array)[3]\n      )\n   )\n\n   preview\n   (\n      #(\n        \"[\",\n        4,\n        \"](\",\n        #array(expr: $e.m_storage.m_data.array[$i], size: 4),\n        \")\"\n      )\n   )\n}\n\n; Fixed size 3-vectors\nEigen::Matrix<*,3,1,*,*,*>|Eigen::Matrix<*,1,3,*,*,*>{\n   children\n   (\n      #(\n        [internals]: [$c,!],\n         x : ($c.m_storage.m_data.array)[0],\n         y : ($c.m_storage.m_data.array)[1],\n         z : ($c.m_storage.m_data.array)[2]\n      )\n   )\n\n   preview\n   (\n      #(\n        \"[\",\n        3,\n        \"](\",\n        #array(expr: $e.m_storage.m_data.array[$i], size: 3),\n        \")\"\n      )\n   )\n}\n\n; Fixed size 2-vectors\nEigen::Matrix<*,2,1,*,*,*>|Eigen::Matrix<*,1,2,*,*,*>{\n   children\n   (\n      #(\n        [internals]: [$c,!],\n         x : ($c.m_storage.m_data.array)[0],\n         y : ($c.m_storage.m_data.array)[1]\n      )\n   )\n\n   preview\n   (\n      #(\n        \"[\",\n        2,\n        \"](\",\n        #array(expr: $e.m_storage.m_data.array[$i], size: 2),\n        \")\"\n      )\n   )\n}\n\n; Fixed size 1-vectors\nEigen::Matrix<*,1,1,*,*,*>|Eigen::Matrix<*,1,1,*,*,*>{\n   children\n   (\n      #(\n        [internals]: [$c,!],\n         x : ($c.m_storage.m_data.array)[0]\n      )\n   )\n\n   preview\n   (\n      #(\n        \"[\",\n        1,\n        \"](\",\n        #array(expr: $e.m_storage.m_data.array[$i], size: 1),\n        \")\"\n      )\n   )\n}\n\n; Dynamic matrices (ColMajor and RowMajor support)\nEigen::Matrix<*,-1,-1,*,*,*>{\n  children\n   (\n      #(\n         [internals]: [$c,!],\n         rows: $c.m_storage.m_rows,\n         cols: $c.m_storage.m_cols,\n         ; Check for RowMajorBit\n         #if ($c.Flags & 0x1) (\n             #array(\n                rank: 2,\n                base: 0,\n                expr: ($c.m_storage.m_data)[($i % $c.m_storage.m_rows)*$c.m_storage.m_cols + (($i- $i % $c.m_storage.m_rows)/$c.m_storage.m_rows)], \n                size: ($r==1)*$c.m_storage.m_rows+($r==0)*$c.m_storage.m_cols\n             )\n         ) #else (\n             #array(\n                rank: 2,\n                base: 0,\n                expr: ($c.m_storage.m_data)[$i],\n                size: ($r==1)*$c.m_storage.m_rows+($r==0)*$c.m_storage.m_cols\n             )\n         )\n      )\n   )\n\n   preview\n   (\n     #(\n         \"[\",\n           $c.m_storage.m_rows,\n         \",\",\n           $c.m_storage.m_cols,\n         \"](\",\n           #array(\n            expr :    [($c.m_storage.m_data)[$i],g],\n            size :    $c.m_storage.m_rows*$c.m_storage.m_cols\n           ),\n         \")\"\n      )\n   )\n}\n\n; Fixed rows, dynamic columns matrix (ColMajor and RowMajor support)\nEigen::Matrix<*,*,-1,*,*,*>{\n  children\n   (\n      #(\n         [internals]: [$c,!],\n         rows: $c.RowsAtCompileTime,\n         cols: $c.m_storage.m_cols,\n         ; Check for RowMajorBit\n         #if ($c.Flags & 0x1) (\n             #array(\n                rank: 2,\n                base: 0,\n                expr: ($c.m_storage.m_data)[($i % $c.RowsAtCompileTime)*$c.m_storage.m_cols + (($i- $i % $c.RowsAtCompileTime)/$c.RowsAtCompileTime)],\n                size: ($r==1)*$c.RowsAtCompileTime+($r==0)*$c.m_storage.m_cols\n             )\n         ) #else (\n             #array(\n                rank: 2,\n                base: 0,\n                expr: ($c.m_storage.m_data)[$i],\n                size: ($r==1)*$c.RowsAtCompileTime+($r==0)*$c.m_storage.m_cols\n             )\n         )\n      )\n   )\n\n   preview\n   (\n     #(\n         \"[\",\n           $c.RowsAtCompileTime,\n         \",\",\n           $c.m_storage.m_cols,\n         \"](\",\n           #array(\n            expr :    [($c.m_storage.m_data)[$i],g],\n            size :    $c.RowsAtCompileTime*$c.m_storage.m_cols\n           ),\n         \")\"\n      )\n   )\n}\n\n; Dynamic rows, fixed columns matrix (ColMajor and RowMajor support)\nEigen::Matrix<*,-1,*,*,*,*>{\n  children\n   (\n      #(\n         [internals]: [$c,!],\n         rows: $c.m_storage.m_rows,\n         cols: $c.ColsAtCompileTime,\n         ; Check for RowMajorBit\n         #if ($c.Flags & 0x1) (\n             #array(\n                rank: 2,\n                base: 0,\n                expr: ($c.m_storage.m_data)[($i % $c.m_storage.m_rows)*$c.ColsAtCompileTime + (($i- $i % $c.m_storage.m_rows)/$c.m_storage.m_rows)], \n                size: ($r==1)*$c.m_storage.m_rows+($r==0)*$c.ColsAtCompileTime\n             )\n         ) #else (\n             #array(\n                rank: 2,\n                base: 0,\n                expr: ($c.m_storage.m_data)[$i],\n                size: ($r==1)*$c.m_storage.m_rows+($r==0)*$c.ColsAtCompileTime\n             )\n         )\n      )\n   )\n\n   preview\n   (\n     #(\n         \"[\",\n           $c.m_storage.m_rows,\n         \",\",\n           $c.ColsAtCompileTime,\n         \"](\",\n           #array(\n            expr :    [($c.m_storage.m_data)[$i],g],\n            size :    $c.m_storage.m_rows*$c.ColsAtCompileTime\n           ),\n         \")\"\n      )\n   )\n}\n\n; Fixed size matrix (ColMajor and RowMajor support)\nEigen::Matrix<*,*,*,*,*,*>{\n  children\n   (\n      #(\n         [internals]: [$c,!],\n         rows: $c.RowsAtCompileTime,\n         cols: $c.ColsAtCompileTime,\n         ; Check for RowMajorBit\n         #if ($c.Flags & 0x1) (\n             #array(\n                rank: 2,\n                base: 0,\n                expr: ($c.m_storage.m_data.array)[($i % $c.RowsAtCompileTime)*$c.ColsAtCompileTime + (($i- $i % $c.RowsAtCompileTime)/$c.RowsAtCompileTime)], \n                size: ($r==1)*$c.RowsAtCompileTime+($r==0)*$c.ColsAtCompileTime\n             )\n         ) #else (\n             #array(\n                rank: 2,\n                base: 0,\n                expr: ($c.m_storage.m_data.array)[$i],\n                size: ($r==1)*$c.RowsAtCompileTime+($r==0)*$c.ColsAtCompileTime\n             )\n         )\n      )\n   )\n\n   preview\n   (\n     #(\n         \"[\",\n           $c.RowsAtCompileTime,\n         \",\",\n           $c.ColsAtCompileTime,\n         \"](\",\n           #array(\n            expr :    [($c.m_storage.m_data.array)[$i],g],\n            size :    $c.RowsAtCompileTime*$c.ColsAtCompileTime\n           ),\n         \")\"\n      )\n   )\n}\n\n; This section contains visualizers for STL and ATL containers\n; DO NOT MODIFY\nATL::CStringT<char,*>|CSimpleStringT<char,*>|ATL::CSimpleStringT<char,*>{\n\t\tpreview\t\t\t([$e.m_pszData,s])\n\t\tstringview\t\t([$e.m_pszData,sb])\n}\nATL::CStringT<wchar_t,*>|CSimpleStringT<wchar_t,*>|ATL::CSimpleStringT<wchar_t,*>|ATL::CStringT<unsigned short,*>|CSimpleStringT<unsigned short,*>|ATL::CSimpleStringT<unsigned short,*>{\n\t\tpreview\t\t\t([$e.m_pszData,su])\n\t\tstringview\t\t([$e.m_pszData,sub])\n}\nATL::CComBSTR{\n\t\tpreview\t\t\t([$e.m_str,su])\n\t\tstringview\t\t([$e.m_str,sub])\n}\n\n\n; Many visualizers use nested #()s.\n; Why not use #(foo, bar) instead of #(#(foo), #(bar))?\n; The former alphabetically sorts its fields, while the latter does not.\n\n;------------------------------------------------------------------------------\n;  std::pair from <utility>\n;------------------------------------------------------------------------------\nstd::pair<*>{\n\t; pair is previewed with \"(<first>, <second>)\".\n\tpreview (\n\t\t#(\n\t\t\t\"(\",\n\t\t\t$e.first,\n\t\t\t\", \",\n\t\t\t$e.second,\n\t\t\t\")\"\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::tuple from <tuple>\n;------------------------------------------------------------------------------\n; tuple is visualized like pair, except that we have to give fake names to tuple's children.\nstd::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>{\n\tpreview (\n\t\t\"()\"\n\t)\n}\nstd::tuple<*,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>{\n\tpreview (\n\t\t#(\n\t\t\t\"(\", $e._Myfirst._Val,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t[0] : $e._Myfirst._Val\n\t\t)\n\t)\n}\nstd::tuple<*,*,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>{\n\tpreview (\n\t\t#(\n\t\t\t\"(\", $e._Myfirst._Val,\n\t\t\t\", \", ((std::tuple<$T1,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t[0] : $e._Myfirst._Val,\n\t\t\t[1] : ((std::tuple<$T1,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val\n\t\t)\n\t)\n}\nstd::tuple<*,*,*,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>{\n\tpreview (\n\t\t#(\n\t\t\t\"(\", $e._Myfirst._Val,\n\t\t\t\", \", ((std::tuple<$T1,$T2,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t\", \", ((std::tuple<$T1,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t[0] : $e._Myfirst._Val,\n\t\t\t[1] : ((std::tuple<$T1,$T2,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t[2] : ((std::tuple<$T1,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val\n\t\t)\n\t)\n}\nstd::tuple<*,*,*,*,std::_Nil,std::_Nil,std::_Nil,std::_Nil>{\n\tpreview (\n\t\t#(\n\t\t\t\"(\", $e._Myfirst._Val,\n\t\t\t\", \", ((std::tuple<$T1,$T2,$T3,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t\", \", ((std::tuple<$T1,$T2,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t\", \", ((std::tuple<$T1,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t[0] : $e._Myfirst._Val,\n\t\t\t[1] : ((std::tuple<$T1,$T2,$T3,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t[2] : ((std::tuple<$T1,$T2,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t[3] : ((std::tuple<$T1,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val\n\t\t)\n\t)\n}\nstd::tuple<*,*,*,*,*,std::_Nil,std::_Nil,std::_Nil>{\n\tpreview (\n\t\t#(\n\t\t\t\"(\", $e._Myfirst._Val,\n\t\t\t\", \", ((std::tuple<$T1,$T2,$T3,$T4,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t\", \", ((std::tuple<$T1,$T2,$T3,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t\", \", ((std::tuple<$T1,$T2,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t\", \", ((std::tuple<$T1,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t[0] : $e._Myfirst._Val,\n\t\t\t[1] : ((std::tuple<$T1,$T2,$T3,$T4,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t[2] : ((std::tuple<$T1,$T2,$T3,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t[3] : ((std::tuple<$T1,$T2,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val,\n\t\t\t[4] : ((std::tuple<$T1,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> *) &$e)->_Myfirst._Val\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::bitset from <bitset>\n;------------------------------------------------------------------------------\nstd::bitset<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._EEN_BITS,\n\t\t\t\"](\",\n\t\t\t#array(\n\t\t\t\texpr: [($e._Array[$i / $e._Bitsperword] >> ($i % $e._Bitsperword)) & 1,d],\n\t\t\t\tsize: $e._EEN_BITS\n\t\t\t),\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#array(\n\t\t\texpr: [($e._Array[$i / $e._Bitsperword] >> ($i % $e._Bitsperword)) & 1,d],\n\t\t\tsize: $e._EEN_BITS\n\t\t)\n\t)\n}\nstd::bitset<*>::reference{\n\tpreview (\n\t\t[($e._Pbitset->_Array[$e._Mypos / $e._Pbitset->_Bitsperword] >> ($e._Mypos % $e._Pbitset->_Bitsperword)) & 1,d]\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([bitset] : $e._Pbitset),\n\t\t\t#([pos] : $e._Mypos)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::allocator from <memory>\n;------------------------------------------------------------------------------\nstd::allocator<*>{\n\tpreview ( \"allocator\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\n\n;------------------------------------------------------------------------------\n;  std::unique_ptr from <memory>\n;------------------------------------------------------------------------------\nstd::unique_ptr<*>{\n\tpreview (\n\t\t#if ($e._Myptr == 0) (\n\t\t\t\"empty\"\n\t\t) #else (\n\t\t\t#(\n\t\t\t\t\"unique_ptr \",\n\t\t\t\t*$e._Myptr\n\t\t\t )\n\t\t)\n\t)\n\n\tchildren (\n\t\t#if ($e._Myptr == 0) (\n\t\t\t#array(expr: 0, size: 0)\n\t\t) #else (\n\t\t\t#([ptr] : $e._Myptr)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::shared_ptr from <memory>\n;------------------------------------------------------------------------------\nstd::_Ref_count<*>{\n\tpreview ( \"default\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::_Ref_count_del<*>{\n\tpreview ( \"custom deleter\" )\n\tchildren ( #([deleter] : $e._Dtor) )\n}\nstd::_Ref_count_del_alloc<*>{\n\tpreview ( \"custom deleter, custom allocator\" )\n\tchildren (\n\t\t#(\n\t\t\t#([deleter] : $e._Dtor),\n\t\t\t#([allocator] : $e._Myal)\n\t\t)\n\t)\n}\nstd::_Ref_count_obj<*>{\n\tpreview ( \"make_shared\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::_Ref_count_obj_alloc<*>{\n\tpreview ( \"allocate_shared\" )\n\tchildren ( #([allocator] : $e._Myal) )\n}\nstd::shared_ptr<*>{\n\tpreview (\n\t\t; shared_ptr<T> stores a T * _Ptr .\n\t\t#if ($e._Ptr == 0) (\n\t\t\t; A default-constructed shared_ptr has a null _Ptr and a null _Rep,\n\t\t\t; and is formally said to be empty.\n\t\t\t; A shared_ptr constructed from a null pointer has a null _Ptr\n\t\t\t; and a NON-null _Rep . It is formally said to own the null pointer.\n\t\t\t; We preview both with \"empty\".\n\t\t\t\"empty\"\n\t\t) #else (\n\t\t\t; Raw pointers are previewed with \"<pointer value> <object>\".\n\t\t\t; auto_ptr is previewed with \"auto_ptr <object>\".\n\t\t\t; Following these examples, shared_ptr is previewed with\n\t\t\t; \"shared_ptr <object> [N strong refs, M weak refs]\".\n\t\t\t#(\n\t\t\t\t\"shared_ptr \",\n\t\t\t\t*$e._Ptr,\n\t\t\t\t\" [\",\n\t\t\t\t$e._Rep->_Uses,\n\t\t\t\t#if ($e._Rep->_Uses == 1) (\" strong ref\") #else (\" strong refs\"),\n\t\t\t\t#if ($e._Rep->_Weaks - 1 > 0) (\n\t\t\t\t\t#(\n\t\t\t\t\t\t\", \",\n\t\t\t\t\t\t$e._Rep->_Weaks - 1,\n\t\t\t\t\t\t#if ($e._Rep->_Weaks - 1 == 1) (\" weak ref\") #else (\" weak refs\")\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\t\"] [\",\n\t\t\t\t*$e._Rep,\n\t\t\t\t\"]\"\n\t\t\t)\n\t\t\t; Note: _Rep->_Uses counts how many shared_ptrs share ownership of the object,\n\t\t\t; so we directly display it as the strong reference count.\n\t\t\t; _Rep->_Weaks counts how many shared_ptrs and weak_ptrs share ownership of\n\t\t\t; the \"representation object\" (or \"control block\"). All of the shared_ptrs are\n\t\t\t; counted as a single owner. That is, _Weaks is initialized to 1, and when\n\t\t\t; _Uses falls to 0, _Weaks is decremented. This avoids incrementing and decrementing\n\t\t\t; _Weaks every time that a shared_ptr gains or loses ownership. Therefore,\n\t\t\t; _Weaks - 1 is the weak reference count, the number of weak_ptrs that are observing\n\t\t\t; the shared object.\n\t\t)\n\t)\n\n\tchildren (\n\t\t#if ($e._Ptr == 0) (\n\t\t\t; We make empty shared_ptrs (and shared_ptrs that own\n\t\t\t; the null pointer) appear to have no children.\n\t\t\t#array(expr: 0, size: 0)\n\t\t) #else (\n\t\t\t#(\n\t\t\t\t; We make shared_ptr appear to have two children:\n\n\t\t\t\t; Its stored pointer, with a fake name of [ptr].\n\t\t\t\t#([ptr] : $e._Ptr),\n\n\t\t\t\t; Its deleter and allocator, which may be default or custom.\n\t\t\t\t#([deleter and allocator] : *$e._Rep)\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::weak_ptr from <memory>\n;------------------------------------------------------------------------------\nstd::weak_ptr<*>{\n\tpreview (\n\t\t#if ($e._Ptr == 0) (\n\t\t\t\"empty\"\n\t\t) #elif ($e._Rep->_Uses == 0) (\n\t\t\t; weak_ptr is just like shared_ptr, except that a weak_ptr can be expired.\n\t\t\t#(\n\t\t\t\t\"expired [\",\n\t\t\t\t$e._Rep->_Weaks,\n\t\t\t\t#if ($e._Rep->_Weaks == 1) (\" weak ref\") #else (\" weak refs\"),\n\t\t\t\t\"] [\",\n\t\t\t\t*$e._Rep,\n\t\t\t\t\"]\"\n\t\t\t)\n\t\t) #else (\n\t\t\t#(\n\t\t\t\t\"weak_ptr \",\n\t\t\t\t*$e._Ptr,\n\t\t\t\t\" [\",\n\t\t\t\t$e._Rep->_Uses,\n\t\t\t\t#if ($e._Rep->_Uses == 1) (\" strong ref\") #else (\" strong refs\"),\n\t\t\t\t\", \",\n\t\t\t\t$e._Rep->_Weaks - 1,\n\t\t\t\t#if ($e._Rep->_Weaks - 1 == 1) (\" weak ref\") #else (\" weak refs\"),\n\t\t\t\t\"] [\",\n\t\t\t\t*$e._Rep,\n\t\t\t\t\"]\"\n\t\t\t)\n\t\t)\n\t)\n\n\tchildren (\n\t\t#if ($e._Ptr == 0) (\n\t\t\t#array(expr: 0, size: 0)\n\t\t) #elif ($e._Rep->_Uses == 0) (\n\t\t\t; When a weak_ptr is expired, we show its deleter and allocator.\n\t\t\t; The deleter has already been used, but the control block has not yet been deallocated.\n\t\t\t#([deleter and allocator] : *$e._Rep)\n\t\t) #else (\n\t\t\t#(\n\t\t\t\t#([ptr] : $e._Ptr),\n\t\t\t\t#([deleter and allocator] : *$e._Rep)\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::reference_wrapper from <functional>\n;------------------------------------------------------------------------------\nstd::reference_wrapper<*>{\n\tpreview (\n\t\t#if ($e._Callee._EEN_INDIRECT == 1) (\n\t\t\t; For ordinary T, reference_wrapper<T> stores a T * _Callee._Ptr\n\t\t\t; which is non-null. Actual references are previewed with what they\n\t\t\t; refer to, so reference_wrapper<T> is previewed with dereferencing its\n\t\t\t; stored pointer.\n\t\t\t*$e._Callee._Ptr\n\t\t) #else (\n\t\t\t; When T is a pointer to data member type, reference_wrapper<T>\n\t\t\t; stores a T _Callee._Object directly.\n\t\t\t$e._Callee._Object\n\t\t)\n\t)\n\n\tchildren (\n\t\t#if ($e._Callee._EEN_INDIRECT == 1) (\n\t\t\t; Actual references have the same children as what they refer to.\n\t\t\t; Unfortunately, there appears to be no way to imitate this exactly.\n\t\t\t; Therefore, we make reference_wrapper<T> appear to have a single\n\t\t\t; child, its stored pointer, with a fake name of [ptr].\n\t\t\t#([ptr] : $e._Callee._Ptr)\n\t\t) #else (\n\t\t\t; When T is a pointer to data member type, T has no children,\n\t\t\t; so we make reference_wrapper<T> appear to have no children.\n\t\t\t#array(expr: 0, size: 0)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::plus, etc. from <functional>\n;------------------------------------------------------------------------------\n; STL functors are previewed with their names.\n; They have no state, so they have no children.\nstd::plus<*>{\n\tpreview ( \"plus\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::minus<*>{\n\tpreview ( \"minus\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::multiplies<*>{\n\tpreview ( \"multiplies\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::divides<*>{\n\tpreview ( \"divides\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::modulus<*>{\n\tpreview ( \"modulus\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::negate<*>{\n\tpreview ( \"negate\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::equal_to<*>{\n\tpreview ( \"equal_to\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::not_equal_to<*>{\n\tpreview ( \"not_equal_to\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::greater<*>{\n\tpreview ( \"greater\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::less<*>{\n\tpreview ( \"less\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::greater_equal<*>{\n\tpreview ( \"greater_equal\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::less_equal<*>{\n\tpreview ( \"less_equal\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::logical_and<*>{\n\tpreview ( \"logical_and\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::logical_or<*>{\n\tpreview ( \"logical_or\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::logical_not<*>{\n\tpreview ( \"logical_not\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::bit_and<*>{\n\tpreview ( \"bit_and\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::bit_or<*>{\n\tpreview ( \"bit_or\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::bit_xor<*>{\n\tpreview ( \"bit_xor\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::identity<*>{\n\tpreview ( \"identity\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\n\n;------------------------------------------------------------------------------\n;  std::not1() from <functional>\n;  std::not2() from <functional>\n;------------------------------------------------------------------------------\n; STL negators are previewed with \"not[12](<stored functor>)\".\n; They have a child with the fake name of [pred], so that the\n; stored functor can be inspected.\nstd::unary_negate<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"not1(\",\n\t\t\t$e._Functor,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#([pred] : $e._Functor)\n\t)\n}\nstd::binary_negate<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"not2(\",\n\t\t\t$e._Functor,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#([pred] : $e._Functor)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::bind1st() from <functional>\n;  std::bind2nd() from <functional>\n;------------------------------------------------------------------------------\n; STL binders are previewed with \"bind1st(<op>, <value>)\" or \"bind2nd(<op>, <value>)\".\n; We gloss over the fact that they derive from unary_function.\nstd::binder1st<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"bind1st(\",\n\t\t\t$e.op,\n\t\t\t\", \",\n\t\t\t$e.value,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(op : $e.op),\n\t\t\t#(value : $e.value)\n\t\t)\n\t)\n}\nstd::binder2nd<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"bind2nd(\",\n\t\t\t$e.op,\n\t\t\t\", \",\n\t\t\t$e.value,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(op : $e.op),\n\t\t\t#(value : $e.value)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::ptr_fun() from <functional>\n;------------------------------------------------------------------------------\n; STL function pointer adaptors are previewed with \"ptr_fun(<stored function pointer>)\".\n; Function pointers have no children, so the adaptors have no children.\nstd::pointer_to_unary_function<*>|std::pointer_to_binary_function<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"ptr_fun(\",\n\t\t\t$e._Pfun,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren ( #array(expr: 0, size: 0) )\n}\n\n;------------------------------------------------------------------------------\n;  std::mem_fun() from <functional>\n;  std::mem_fun_ref() from <functional>\n;------------------------------------------------------------------------------\n; See ptr_fun().\nstd::mem_fun_t<*>|std::mem_fun1_t<*>|std::const_mem_fun_t<*>|std::const_mem_fun1_t<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"mem_fun(\",\n\t\t\t$e._Pmemfun,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::mem_fun_ref_t<*>|std::mem_fun1_ref_t<*>|std::const_mem_fun_ref_t<*>|std::const_mem_fun1_ref_t<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"mem_fun_ref(\",\n\t\t\t$e._Pmemfun,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren ( #array(expr: 0, size: 0) )\n}\n\n;------------------------------------------------------------------------------\n;  std::auto_ptr from <memory>\n;------------------------------------------------------------------------------\nstd::auto_ptr<*>{\n\t; An empty auto_ptr is previewed with \"empty\".\n\t; Otherwise, it is previewed with \"auto_ptr <object>\".\n\tpreview (\n\t\t#if ($e._Myptr == 0) (\n\t\t\t\"empty\"\n\t\t) #else (\n\t\t\t#(\n\t\t\t\t\"auto_ptr \",\n\t\t\t\t*$e._Myptr\n\t\t\t )\n\t\t)\n\t)\n\n\t; An empty auto_ptr has no children.\n\t; Otherwise, it has a single child, its stored pointer, with a fake name of [ptr].\n\tchildren (\n\t\t#if ($e._Myptr == 0) (\n\t\t\t#array(expr: 0, size: 0)\n\t\t) #else (\n\t\t\t#([ptr] : $e._Myptr)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::bind() from <functional>\n;------------------------------------------------------------------------------\n; bind() placeholders are previewed with their names.\n; They have no state, so they have no children.\nstd::_Ph<1>{\n\tpreview ( \"_1\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::_Ph<2>{\n\tpreview ( \"_2\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::_Ph<3>{\n\tpreview ( \"_3\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::_Ph<4>{\n\tpreview ( \"_4\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::_Ph<5>{\n\tpreview ( \"_5\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::_Ph<6>{\n\tpreview ( \"_6\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::_Ph<7>{\n\tpreview ( \"_7\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::_Ph<8>{\n\tpreview ( \"_8\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::_Ph<9>{\n\tpreview ( \"_9\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\nstd::_Ph<10>{\n\tpreview ( \"_10\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\n\n; The functor returned by bind(f, t1, t2) is previewed with \"bind(f, (t1, t2))\".\n; It has children with the fake names of [f] and [bound_args].\nstd::_Bind<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"bind(\", $e._Myfun,\n\t\t\t\", \", $e._Mybargs,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([f] : $e._Myfun),\n\t\t\t#([bound_args] : $e._Mybargs)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::mem_fn() from <functional>\n;------------------------------------------------------------------------------\n; Note that when mem_fn() is given a data member pointer, it returns a _Call_wrapper<_Callable_pmd<*> > .\n; Data member pointers themselves don't have useful previews, so we don't attempt to visualize this.\n; When mem_fn() is given a member function pointer, it returns a _Mem_fn_wrap, which we can visualize.\nstd::_Mem_fn_wrap<*>{\n\tpreview (\n\t\t; We preview the functor returned by mem_fn() with \"mem_fn(<stored member function pointer>)\".\n\t\t#(\n\t\t\t\"mem_fn(\",\n\t\t\t$e._Callee._Object,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t; Member function pointers have no children.\n\t\t#array(expr: 0, size: 0)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::function from <functional>\n;------------------------------------------------------------------------------\n; std::_Func_impl_no_alloc<*>{\n; \tpreview ( $e._Callee._Object )\n; \tchildren ( #([functor] : $e._Callee._Object) )\n; }\nstd::_Func_impl<*>{\n\tpreview ( $e._Callee._Object )\n\tchildren (\n\t\t#(\n\t\t\t#([functor] : $e._Callee._Object),\n\t\t\t#([allocator] : $e._Myal)\n\t\t)\n\t)\n}\nstd::function<*>{\n\tpreview (\n\t\t#if ($e._Impl == 0) (\n\t\t\t; Detecting empty functions is trivial.\n\t\t\t\"empty\"\n\t\t) #else (\n\t\t\t*$e._Impl\n\t\t)\n\t)\n\n\tchildren (\n\t\t#if ($e._Impl == 0) (\n\t\t\t; We make empty functions appear to have no children.\n\t\t\t#array(expr: 0, size: 0)\n\t\t) #else (\n\t\t\t#([functor and allocator] : *$e._Impl)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::hash from <functional>\n;------------------------------------------------------------------------------\nstd::hash<*>{\n\tpreview ( \"hash\" )\n\tchildren ( #array(expr: 0, size: 0) )\n}\n\n;------------------------------------------------------------------------------\n;  std::basic_string from <string>\n;------------------------------------------------------------------------------\n; basic_string is previewed with its stored string.\n; It has [size] and [capacity] children, followed by [0], [1], [2], etc. children\n; displaying its stored characters.\n; The ($e._Myres) < ($e._BUF_SIZE) test determines whether the Small String Optimization\n; is in effect.\n; NOTE: The parentheses in ($e._Myres) < ($e._BUF_SIZE) are necessary.\nstd::basic_string<char,*>{\n\tpreview\t\t( #if (($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,s] ) #else ( [$e._Bx._Ptr,s] ))\n\tstringview\t( #if (($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,sb] ) #else ( [$e._Bx._Ptr,sb] ))\n\n\tchildren (\n\t\t#(\n\t\t\t#([size] : $e._Mysize),\n\t\t\t#([capacity] : $e._Myres),\n\t\t\t#if (($e._Myres) < ($e._BUF_SIZE)) (\n\t\t\t\t#array(expr: $e._Bx._Buf[$i], size: $e._Mysize)\n\t\t\t) #else (\n\t\t\t\t#array(expr: $e._Bx._Ptr[$i], size: $e._Mysize)\n\t\t\t)\n\t\t)\n\t)\n}\nstd::basic_string<unsigned short,*>|std::basic_string<wchar_t,*>{\n\tpreview\t\t( #if (($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,su] ) #else ( [$e._Bx._Ptr,su] ))\n\tstringview\t( #if (($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,sub] ) #else ( [$e._Bx._Ptr,sub] ))\n\n\tchildren (\n\t\t#(\n\t\t\t#([size] : $e._Mysize),\n\t\t\t#([capacity] : $e._Myres),\n\t\t\t#if (($e._Myres) < ($e._BUF_SIZE)) (\n\t\t\t\t#array(expr: $e._Bx._Buf[$i], size: $e._Mysize)\n\t\t\t) #else (\n\t\t\t\t#array(expr: $e._Bx._Ptr[$i], size: $e._Mysize)\n\t\t\t)\n\t\t)\n\t)\n}\nstd::_String_iterator<std::_String_val<std::_Simple_types<char> > >|std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >{\n\tpreview\t\t( [$e._Ptr,s] )\n\tstringview\t( [$e._Ptr,sb] )\n\tchildren\t( #([ptr] : $e._Ptr) )\n}\nstd::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >|std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >|std::_String_iterator<std::_String_val<std::_Simple_types<unsigned short> > >|std::_String_const_iterator<std::_String_val<std::_Simple_types<unsigned short> > >{\n\tpreview\t\t( [$e._Ptr,su] )\n\tstringview\t( [$e._Ptr,sub] )\n\tchildren\t( #([ptr] : $e._Ptr) )\n}\n\n;------------------------------------------------------------------------------\n;  std::array from <array>\n;------------------------------------------------------------------------------\nstd::array<*>{\n\tpreview (\n\t\t; An actual array is previewed with its address.\n\t\t; array<T, N> is previewed like vector<T>.\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._EEN_SIZE,\n\t\t\t\"](\",\n\t\t\t#array(expr: $e._Elems[$i], size: $e._EEN_SIZE),\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t; Just like an actual array.\n\t\t#array(expr: $e._Elems[$i], size: $e._EEN_SIZE)\n\t)\n}\nstd::_Array_iterator<*>|std::_Array_const_iterator<*>{\n\tpreview (\n\t\t#if ($e._EEN_IDL == 0) (\n\t\t\t*$e._Ptr\n\t\t) #else (\n\t\t\t#if ($e._Idx == $e._EEN_SIZE) (\n\t\t\t\t; array iterators are represented by _Ptr + _Idx,\n\t\t\t\t; and they know how large their parent arrays are. Therefore, detecting\n\t\t\t\t; end iterators is trivial.\n\t\t\t\t\"end\"\n\t\t\t) #else (\n\t\t\t\t; Like vector iterators, array iterators are previewed with what they point to.\n\t\t\t\t$e._Ptr[$e._Idx]\n\t\t\t)\n\t\t)\n\t)\n\n\tchildren (\n\t\t#if ($e._EEN_IDL == 0) (\n\t\t\t#([ptr] : $e._Ptr)\n\t\t) #else (\n\t\t\t#if ($e._Idx == $e._EEN_SIZE) (\n\t\t\t\t; We make end iterators appear to have no children.\n\t\t\t\t#array(expr: 0, size: 0)\n\t\t\t) #else (\n\t\t\t\t; An array iterator is conceptually a pointer, so we make it appear to store one.\n\t\t\t\t#([ptr] : $e._Ptr + $e._Idx)\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::deque from <deque>\n;------------------------------------------------------------------------------\nstd::deque<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._Mysize,\n\t\t\t\"](\",\n\t\t\t#array(\n\t\t\t\texpr: $e._Map[(($i + $e._Myoff) / $e._EEN_DS) % $e._Mapsize][($i + $e._Myoff) % $e._EEN_DS],\n\t\t\t\tsize: $e._Mysize\n\t\t\t),\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#array(\n\t\t\t\texpr: $e._Map[(($i + $e._Myoff) / $e._EEN_DS) % $e._Mapsize][($i + $e._Myoff) % $e._EEN_DS],\n\t\t\t\tsize: $e._Mysize\n\t\t\t)\n\t\t)\n\t)\n}\nstd::_Deque_iterator<*>|std::_Deque_const_iterator<*>{\n\tpreview (\n\t\t#if ($e._Myoff >= (($T1 *)$e._Myproxy->_Mycont)->_Myoff + (($T1 *)$e._Myproxy->_Mycont)->_Mysize) (\n\t\t\t\"end\"\n\t\t) #else (\n\t\t\t(($T1 *)$e._Myproxy->_Mycont)->_Map[($e._Myoff / $e._EEN_DS) % (($T1 *)$e._Myproxy->_Mycont)->_Mapsize][$e._Myoff % $e._EEN_DS]\n\t\t)\n\t)\n\n\tchildren (\n\t\t#if ($e._Myoff >= (($T1 *)$e._Myproxy->_Mycont)->_Myoff + (($T1 *)$e._Myproxy->_Mycont)->_Mysize) (\n\t\t\t#array(expr: 0, size: 0)\n\t\t) #else (\n\t\t\t#(\n\t\t\t\t#([index] : $e._Myoff - (($T1 *)$e._Myproxy->_Mycont)->_Myoff),\n\t\t\t\t#([ptr] : &(($T1 *)$e._Myproxy->_Mycont)->_Map[($e._Myoff / $e._EEN_DS) % (($T1 *)$e._Myproxy->_Mycont)->_Mapsize][$e._Myoff % $e._EEN_DS] )\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::forward_list from <forward_list>\n;------------------------------------------------------------------------------\nstd::forward_list<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"(\",\n\t\t\t#list(\n\t\t\t\thead: $e._Myhead,\n\t\t\t\tnext: _Next\n\t\t\t) : $e._Myval,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#list(\n\t\t\thead: $e._Myhead,\n\t\t\tnext: _Next\n\t\t) : $e._Myval\n\t)\n}\nstd::_Flist_iterator<*>|std::_Flist_const_iterator<*>{\n\tpreview (\n\t\t#if ($e._Ptr == 0) (\n\t\t\t\"end\"\n\t\t) #else (\n\t\t\t$e._Ptr->_Myval\n\t\t)\n\t)\n\n\tchildren (\n\t\t#if ($e._Ptr == 0) (\n\t\t\t#array(expr: 0, size: 0)\n\t\t) #else (\n\t\t\t#([ptr] : &$e._Ptr->_Myval)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::list from <list>\n;------------------------------------------------------------------------------\nstd::list<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._Mysize,\n\t\t\t\"](\",\n\t\t\t#list(\n\t\t\t\thead: $e._Myhead->_Next,\n\t\t\t\tsize: $e._Mysize,\n\t\t\t\tnext: _Next\n\t\t\t) : $e._Myval,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#list(\n\t\t\thead: $e._Myhead->_Next,\n\t\t\tsize: $e._Mysize,\n\t\t\tnext: _Next\n\t\t) : $e._Myval\n\t)\n}\nstd::_List_iterator<*>|std::_List_const_iterator<*>{\n\tpreview ( $e._Ptr->_Myval )\n\tchildren ( #([ptr] : &$e._Ptr->_Myval) )\n}\n\n;------------------------------------------------------------------------------\n;  std::vector<bool> from <vector>\n;------------------------------------------------------------------------------\n; Despite its packed representation, vector<bool> is visualized like vector<T>.\nstd::vector<bool,*>{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._Mysize,\n\t\t\t\"](\",\n\t\t\t#array(\n\t\t\t\texpr: (bool)(($e._Myvec._Myfirst[$i / $e._EEN_VBITS] >> ($i % $e._EEN_VBITS)) & 1),\n\t\t\t\tsize: $e._Mysize\n\t\t\t),\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([size] : $e._Mysize),\n\t\t\t#([capacity] : ($e._Myvec._Myend - $e._Myvec._Myfirst) * $e._EEN_VBITS),\n\t\t\t#array(\n\t\t\t\texpr: (bool)(($e._Myvec._Myfirst[$i / $e._EEN_VBITS] >> ($i % $e._EEN_VBITS)) & 1),\n\t\t\t\tsize: $e._Mysize\n\t\t\t)\n\t\t)\n\t)\n}\nstd::_Vb_reference<*>|std::_Vb_iterator<*>|std::_Vb_const_iterator<*>{\n\tpreview (\n\t\t(bool)((*$e._Myptr >> $e._Myoff) & 1)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([ptr] : $e._Myptr),\n\t\t\t#([offset] : $e._Myoff)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::vector from <vector>\n;------------------------------------------------------------------------------\n; vector is previewed with \"[<size>](<elements>)\".\n; It has [size] and [capacity] children, followed by its elements.\n; The other containers follow its example.\nstd::vector<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._Mylast - $e._Myfirst,\n\t\t\t\"](\",\n\t\t\t#array(\n\t\t\t\texpr: $e._Myfirst[$i],\n\t\t\t\tsize: $e._Mylast - $e._Myfirst\n\t\t\t),\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([size] : $e._Mylast - $e._Myfirst),\n\t\t\t#([capacity] : $e._Myend - $e._Myfirst),\n\t\t\t#array(\n\t\t\t\texpr: $e._Myfirst[$i],\n\t\t\t\tsize: $e._Mylast - $e._Myfirst\n\t\t\t)\n\t\t)\n\t)\n}\nstd::_Vector_iterator<*>|std::_Vector_const_iterator<*>{\n\tpreview (\n\t\t*$e._Ptr\n\t)\n\n\tchildren (\n\t\t#([ptr] : $e._Ptr)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::map from <map>\n;  std::multimap from <map>\n;  std::set from <set>\n;  std::multiset from <set>\n;------------------------------------------------------------------------------\nstd::map<*>|std::multimap<*>|std::set<*>|std::multiset<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._Mysize,\n\t\t\t\"](\",\n\t\t\t#tree(\n\t\t\t\thead: $e._Myhead->_Parent,\n\t\t\t\tskip: $e._Myhead,\n\t\t\t\tleft: _Left,\n\t\t\t\tright: _Right,\n\t\t\t\tsize: $e._Mysize\n\t\t\t) : $e._Myval,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#tree(\n\t\t\t\thead: $e._Myhead->_Parent,\n\t\t\t\tskip: $e._Myhead,\n\t\t\t\tleft: _Left,\n\t\t\t\tright: _Right,\n\t\t\t\tsize: $e._Mysize\n\t\t\t) : $e._Myval\n\t\t)\n\t)\n}\nstd::_Tree_iterator<*>|std::_Tree_const_iterator<*>{\n\tpreview ( $e._Ptr->_Myval )\n\tchildren ( #([ptr] : &$e._Ptr->_Myval) )\n}\n\n;------------------------------------------------------------------------------\n;  std::unordered_map from <unordered_map>\n;  std::unordered_multimap from <unordered_map>\n;  std::unordered_set from <unordered_set>\n;  std::unordered_multiset from <unordered_set>\n;  stdext::hash_map from <hash_map>\n;  stdext::hash_multimap from <hash_map>\n;  stdext::hash_set from <hash_set>\n;  stdext::hash_multiset from <hash_set>\n;------------------------------------------------------------------------------\nstd::unordered_map<*>|std::unordered_multimap<*>|std::unordered_set<*>|std::unordered_multiset<*>|stdext::hash_map<*>|stdext::hash_multimap<*>|stdext::hash_set<*>|stdext::hash_multiset<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._List._Mysize,\n\t\t\t\"](\",\n\t\t\t#list(\n\t\t\t\thead: $e._List._Myhead->_Next,\n\t\t\t\tsize: $e._List._Mysize,\n\t\t\t\tnext: _Next\n\t\t\t) : $e._Myval,\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#list(\n\t\t\thead: $e._List._Myhead->_Next,\n\t\t\tsize: $e._List._Mysize,\n\t\t\tnext: _Next\n\t\t) : $e._Myval\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::queue from <queue>\n;  std::stack from <stack>\n;------------------------------------------------------------------------------\nstd::queue<*>|std::stack<*>{\n\tpreview ( $e.c )\n\tchildren ( #(c : $e.c) )\n}\n\n;------------------------------------------------------------------------------\n;  std::priority_queue from <queue>\n;------------------------------------------------------------------------------\nstd::priority_queue<*>{\n\tpreview ( $e.c )\n\n\tchildren (\n\t\t#(\n\t\t\t#(c [heap]: $e.c),\n\t\t\t#(comp : $e.comp)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::reverse_iterator, etc. from <iterator>\n;------------------------------------------------------------------------------\nstd::reverse_iterator<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"reverse_iterator current \",\n\t\t\t$e.current\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(current : $e.current)\n\t)\n}\nstd::back_insert_iterator<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"back_insert_iterator into \",\n\t\t\t$e.container\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(container : $e.container)\n\t)\n}\nstd::front_insert_iterator<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"front_insert_iterator into \",\n\t\t\t$e.container\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(container : $e.container)\n\t)\n}\nstd::insert_iterator<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"insert_iterator into \",\n\t\t\t$e.container,\n\t\t\t\" at \",\n\t\t\t$e.iter\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(container : $e.container),\n\t\t\t#(iter : $e.iter)\n\t\t)\n\t)\n}\nstd::move_iterator<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"move_iterator current \",\n\t\t\t$e.current\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(current : $e.current)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::complex from <complex>\n;------------------------------------------------------------------------------\nstd::complex<*>{\n\tpreview (\n\t\t#if ($e._Val[1] == 0) (\n\t\t\t; Purely real.\n\t\t\t$e._Val[0]\n\t\t) #else (\n\t\t\t#if ($e._Val[0] == 0) (\n\t\t\t\t; Purely imaginary.\n\t\t\t\t#if ($e._Val[1] < 0) (\n\t\t\t\t\t#(\"-i*\", -$e._Val[1])\n\t\t\t\t) #else (\n\t\t\t\t\t#(\"i*\", $e._Val[1])\n\t\t\t\t)\n\t\t\t) #else (\n\t\t\t\t; Mixed.\n\t\t\t\t#if ($e._Val[1] < 0) (\n\t\t\t\t\t#($e._Val[0], \"-i*\", -$e._Val[1])\n\t\t\t\t) #else (\n\t\t\t\t\t#($e._Val[0], \"+i*\", $e._Val[1])\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(real : $e._Val[0]),\n\t\t\t#(imag : $e._Val[1])\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::valarray from <valarray>\n;------------------------------------------------------------------------------\nstd::valarray<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._Mysize,\n\t\t\t\"](\",\n\t\t\t#array(\n\t\t\t\texpr: $e._Myptr[$i],\n\t\t\t\tsize: $e._Mysize\n\t\t\t),\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#array(\n\t\t\texpr: $e._Myptr[$i],\n\t\t\tsize: $e._Mysize\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::basic_regex from <regex>\n;------------------------------------------------------------------------------\nstd::basic_regex<*>{\n\tpreview (\n\t\t#if ($e._Rep == 0) (\n\t\t\t; Default construction creates an empty basic_regex.\n\t\t\t\"empty\"\n\t\t) #elif ($e._EEN_VIS == 1) (\n\t\t\t; By default, _ENHANCED_REGEX_VISUALIZER is defined to be 1 in debug and 0 in ship.\n\t\t\t; When it is 1, basic_regex stores the string from which it was constructed.\n\t\t\t; When it is 0, basic_regex stores only the resulting finite state machine.\n\t\t\t$e._Visualization\n\t\t) #else (\n\t\t\t; basic_regex contains many static const flags, which would be shown in the preview by default.\n\t\t\t; Its actual members are _Rep and _Traits. _Rep holds the finite state machine, so we\n\t\t\t; use it to preview basic_regex. (It does contain some human-readable information.)\n\t\t\t*$e._Rep\n\t\t)\n\t)\n\n\tchildren (\n\t\t#if ($e._Rep == 0) (\n\t\t\t; We make empty basic_regexes appear to have no children.\n\t\t\t#array(expr: 0, size: 0)\n\t\t) #elif ($e._EEN_VIS == 1) (\n\t\t\t; We want to hide those static const flags.\n\t\t\t; We also want to give _Visualization a fake name.\n\t\t\t#(\n\t\t\t\t#([str] : $e._Visualization),\n\t\t\t\t#(_Rep : $e._Rep),\n\t\t\t\t#(_Traits : $e._Traits)\n\t\t\t)\n\t\t) #else (\n\t\t\t; We want to hide those static const flags.\n\t\t\t#(\n\t\t\t\t_Rep : $e._Rep,\n\t\t\t\t_Traits : $e._Traits\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::sub_match from <regex>\n;------------------------------------------------------------------------------\nstd::sub_match<char const *>|std::sub_match<wchar_t const *>|std::sub_match<unsigned short const *>|std::sub_match<char *>|std::sub_match<wchar_t *>|std::sub_match<unsigned short *>{\n\tpreview (\n\t\t; It would be nice if we could preview sub_match with its str().\n\t\t; However, visualizers cannot handle strings represented by pointer pairs.\n\t\t; Therefore, our preview contains more limited information.\n\t\t#if ($e.matched) (\n\t\t\t; If this sub_match participated in a match,\n\t\t\t; we preview it with its length().\n\t\t\t$e.second - $e.first\n\t\t) #else (\n\t\t\t; Otherwise, we preview it with its matched bool (i.e. \"false\").\n\t\t\t; (Why not length() (i.e. \"0\")? It's meaningful to have\n\t\t\t; matched == true and length() == 0.\n\t\t\t\"false\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t; sub_match's three data members are public, but we list them here\n\t\t\t; (a) to display matched before first and second, and\n\t\t\t; (b) to gloss over the fact that sub_match derives from std::pair.\n\t\t\t#(matched : $e.matched),\n\t\t\t#(first : $e.first),\n\t\t\t#(second : $e.second)\n\t\t)\n\t)\n}\nstd::sub_match<std::_String_const_iterator<*> >|std::sub_match<std::_String_iterator<*> >{\n\tpreview (\n\t\t#if ($e.matched) (\n\t\t\t; We visualize ssub_match and wssub_match just like csub_match and wcsub_match,\n\t\t\t; except that when determining the length(), we can't subtract iterators.\n\t\t\t; We have to subtract their stored pointers.\n\t\t\t$e.second._Ptr - $e.first._Ptr\n\t\t) #else (\n\t\t\t\"false\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(matched : $e.matched),\n\t\t\t#(first : $e.first),\n\t\t\t#(second : $e.second)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::match_results from <regex>\n;------------------------------------------------------------------------------\nstd::match_results<*>{\n\tpreview (\n\t\t; A match_results object is empty iff its vector _Matches is empty.\n\t\t#if ($e._Matches._Myfirst == $e._Matches._Mylast) (\n\t\t\t\"empty\"\n\t\t) #else (\n\t\t\t; We preview a non-empty match_results object with its vector.\n\t\t\t$e._Matches\n\t\t)\n\t)\n\n\tchildren (\n\t\t#if ($e._Matches._Myfirst == $e._Matches._Mylast) (\n\t\t\t; We make empty match_results appear to have no children.\n\t\t\t#array(expr: 0, size: 0)\n\t\t) #else (\n\t\t\t; As match_results has operator[](), prefix(), and suffix() member functions,\n\t\t\t; we make it appear to directly contain [0], [1], [2], etc. elements,\n\t\t\t; as well as [prefix] and [suffix] elements.\n\t\t\t#(\n\t\t\t\t#array(expr: $e._Matches._Myfirst[$i], size: $e._Matches._Mylast - $e._Matches._Myfirst),\n\t\t\t\t#([prefix] : $e._Prefix),\n\t\t\t\t#([suffix] : $e._Suffix)\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::regex_iterator from <regex>\n;------------------------------------------------------------------------------\nstd::regex_iterator<*>{\n\tpreview (\n\t\t#if ($e._MyRe == 0) (\n\t\t\t; We represent end-of-sequence regex_iterators with null regex pointers.\n\t\t\t\"end\"\n\t\t) #else (\n\t\t\t; Dereferenceable regex_iterators return match_results when dereferenced,\n\t\t\t; so we'll preview them with that.\n\t\t\t$e._MyVal\n\t\t)\n\t)\n\n\tchildren (\n\t\t#if ($e._MyRe == 0) (\n\t\t\t; We make end-of-sequence regex_iterators appear to have no children.\n\t\t\t#array(expr: 0, size: 0)\n\t\t) #else (\n\t\t\t; For ease of understanding, we make dereferenceable regex_iterators\n\t\t\t; appear to have data members with the \"for exposition only\" names from TR1.\n\t\t\t#(\n\t\t\t\t#([begin] : $e._Begin),\n\t\t\t\t#([end] : $e._End),\n\t\t\t\t#([pregex] : $e._MyRe),\n\t\t\t\t#([flags] : $e._Flags),\n\t\t\t\t#([match] : $e._MyVal)\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  std::regex_token_iterator from <regex>\n;------------------------------------------------------------------------------\nstd::regex_token_iterator<*>{\n\tpreview (\n\t\t#if ($e._Res == 0) (\n\t\t\t; We represent end-of-sequence regex_token_iterators with null result pointers.\n\t\t\t\"end\"\n\t\t) #else (\n\t\t\t; Dereferenceable regex_token_iterators return *result when dereferenced,\n\t\t\t; so we'll preview them with that.\n\t\t\t*$e._Res\n\t\t)\n\t)\n\n\tchildren (\n\t\t#if ($e._Res == 0) (\n\t\t\t; We make end-of-sequence regex_token_iterators appear to have no children.\n\t\t\t#array(expr: 0, size: 0)\n\t\t) #else (\n\t\t\t; For ease of understanding, we make dereferenceable regex_token_iterators\n\t\t\t; appear to have data members with the \"for exposition only\" names from TR1.\n\t\t\t#(\n\t\t\t\t#([position] : $e._Pos),\n\t\t\t\t#([result] : $e._Res),\n\t\t\t\t#([suffix] : $e._Suffix),\n\t\t\t\t#([N] : $e._Cur),\n\t\t\t\t#([subs] : $e._Subs)\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  PROPVARIANT\n;------------------------------------------------------------------------------\n; Visualizers for VT_VECTOR C arrays\ntagCAC|tagCAUB|tagCAI|tagCAUI|tagCAL|tagCAUL|tagCAFLT|tagCADBL|tagCACY|tagCADATE|tagCABSTR|tagCABSTRBLOB|tagCABOOL|tagCASCODE|tagCAPROPVARIANT|tagCAH|tagCAUH|tagCALPSTR|tagCALPWSTR|tagCAFILETIME|tagCACLIPDATA|tagCACLSID{\n\tpreview(\n\t\t#(\n\t\t\t\"[\", $e.cElems , \"](\",\n\t\t\t#array\n\t\t\t(\n\t\t\t\texpr :\t($e.pElems)[$i],\n\t\t\t\tsize :\t$e.cElems\n\t\t\t),\n\t\t\t\")\"\n\t\t)\n\t)\n\tchildren\n\t(\n\t\t#array\n\t\t(\n\t\t\texpr :\t($e.pElems)[$i],\n\t\t\tsize :\t$e.cElems\n\t\t)\n\t)\n}\n; Visualizers for SAFE ARRAY\ntagSAFEARRAY|SAFEARRAY{\n\tpreview(\n\t\t#if ($e.fFeatures & 0x0080)\t\t; FADF_HAVEVARTYPE\n\t\t(\n\t\t\t; Switch on the variant type field - which is stored 4 bytes\n\t\t\t; before the beginning of the SAFEARRAY type\n\t\t\t#switch( ((unsigned *)&($e))[-1] )\n\t\t\t#case 0x2\t\t; VT_I2 | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of I2 = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((signed short *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x3\t\t; VT_I4 | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of I4 = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((signed int *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x4\t\t; VT_R4 | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of R4 = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((float *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x5\t\t; VT_R8 | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of R8 = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((double *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t )\n\t\t\t)\n\t\t\t#case 0x6\t\t; VT_CY | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of CY = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((CY *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x7\t\t; VT_DATE | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of DATE = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((DATE *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x8\t\t; VT_BSTR | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of BSTR = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((wchar_t **)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0xa\t\t; VT_ERROR | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of ERROR = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((long *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0xb\t\t; VT_BOOL | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of BOOL = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((short *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0xc\t\t; VT_VARIANT | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of VARIANT = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((tagVARIANT *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x10\t\t; VT_I1 | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of I1 = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((signed char *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x11\t\t; VT_UI1 | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of UI1 = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((unsigned char *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x12\t\t; VT_UI2 | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of UI2 = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((unsigned short *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t  ),\n\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x13\t\t; VT_UI4 | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of UI4 = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((unsigned int *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x14\t\t; VT_I8 | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of I8 = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((signed __int64 *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x15\t\t; VT_UI8 | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of UI8 = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((unsigned __int64 *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x16\t\t; VT_INT | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of INT = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((int *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x17\t\t; VT_UINT | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of UINT = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((unsigned *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x1e\t\t; VT_LPSTR | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of LPSTR = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((char **)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x1f\t\t; VT_LPWSTR | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of LPWSTR = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((wchar_t **)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x40\t\t; VT_FILETIME | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of FILETIME = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((FILETIME *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x47\t\t; VT_CLIPDATA | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of CLIPDATA = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((CLIPDATA *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#case 0x48\t\t; VT_CLSID | VT_ARRAY\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t\"safearray of CLSID = [\",\n\t\t\t\t\t; output the rank array\n\t\t\t\t\t#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),\n\t\t\t\t\t\"](\",\n\t\t\t\t\t; output the data elements\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((CLSID *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t),\n\t\t\t\t\t\")\"\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t#elif ($e.fFeatures & 0x0100)\t; FADF_BSTR\n\t\t(\n\t\t\t#(\"safearray of BSTR = \",#array(expr: $e.rgsabound[$i].cElements, size: $e.cDims) : #(\"[\",$e,\"]\"), \"(\", #array(expr: ((wchar_t * *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound ), \")\")\n\t\t)\n\t\t#elif ($e.fFeatures & 0x0200)\t; FADF_UNKNOWN\n\t\t(\n\t\t\t#(\"safearray of IUnknown* = [\",#array(expr: $e.rgsabound[$i].cElements, size: $e.cDims), \"](\", #array(expr: ((IUnknown * *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound ), \")\")\n\t\t)\n\t\t#elif ($e.fFeatures & 0x0400)\t; FADF_DISPATCH\n\t\t(\n\t\t\t#(\"safearray of IDispatch* = [\",#array(expr: $e.rgsabound[$i].cElements, size: $e.cDims), \"](\", #array(expr: ((IDispatch * *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound ), \")\")\n\t\t)\n\t\t#elif ($e.fFeatures & 0x0800)\t; FADF_VARIANT\n\t\t(\n\t\t\t\t#(\"safearray of VARIANT = \",#array(expr: $e.rgsabound[$i].cElements, size: $e.cDims) : #(\"[\",$e,\"]\"), \"(\", #array(expr: ((tagVARIANT *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound ), \")\")\n\t\t)\n\t)\n\tchildren\n\t(\n\t\t#(\t\t;[actual members]: [$e,!],\n\t\t\t#if ($e.fFeatures & 0x0080)\t\t; FADF_HAVEVARTYPE\n\t\t\t(\n\t\t\t\t#switch( ((unsigned *)&($e))[-1] )\t\t; for some reason the VT field is before the SAFEARRAY struct\n\t\t\t\t#case 2 ; VT_I2|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((signed short *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 3 ; VT_I4|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((signed int\t *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 4 ; VT_R4|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((float *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 5 ; VT_R8|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((double\t*)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0x10\t\t; VT_I1|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((signed char *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0x11\t\t; VT_UI1|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((unsigned char *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0x12\t\t; VT_UI2|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((unsigned short *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0x13\t\t; VT_UI4|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((unsigned int *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0x14\t\t; VT_I8|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((signed __int64 *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0x15\t\t; VT_UI8|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((unsigned __int64 *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0x1e\t\t; VT_LPSTR|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((char * *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0x1f\t\t; VT_LPWSTR|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((wchar_t **)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0xc\t\t; VT_VARIANT|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((tagVARIANT *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0xb\t\t; VT_BOOL|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((short *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0xa\t\t; VT_ERROR|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((long *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 6 ; VT_CY|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((CY *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 7 ; VT_DATE|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((DATE *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0x40\t\t; VT_FILETIME|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((FILETIME *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0x48\t\t; VT_CLSID|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((CLSID *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0x47\t\t; VT_CF|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((CLIPDATA *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 8 ; VT_BSTR|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((wchar_t * *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0x16\t\t; VT_INT|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((int *)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#case 0x17\t\t; VT_UINT|VT_ARRAY\n\t\t\t\t(\n\t\t\t\t\t#array(\n\t\t\t\t\t\texpr: ((unsigned int*)$e.pvData)[$i],\n\t\t\t\t\t\tsize: $e.rgsabound[$r].cElements,\n\t\t\t\t\t\trank: $e.cDims,\n\t\t\t\t\t\tbase: $e.rgsabound[$r].lLbound\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t#default\n\t\t\t\t(\n\t\t\t\t\t\t#([actual members]: [$e,!])\n\t\t\t\t)\n\t\t\t\t#except\n\t\t\t\t(\n\t\t\t\t\t\t#([actual members]: [$e,!])\n\t\t\t\t)\n\t\t\t)\n\t\t\t#elif ($e.fFeatures & 0x0100)\t; FADF_BSTR\n\t\t\t(\n\t\t\t\t\t#array(expr: ((wchar_t * *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound )\n\t\t\t)\n\t\t\t#elif ($e.fFeatures & 0x0200)\t; FADF_UNKNOWN\n\t\t\t(\n\t\t\t\t\t#array(expr: ((IUnknown * *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound )\n\t\t\t)\n\t\t\t#elif ($e.fFeatures & 0x0400)\t; FADF_DISPATCH\n\t\t\t(\n\t\t\t\t\t#array(expr: ((IDispatch * *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound )\n\t\t\t)\n\t\t\t#elif ($e.fFeatures & 0x0800)\t; FADF_VARIANT\n\t\t\t(\n\t\t\t\t\t#array(expr: ((tagVARIANT *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound )\n\t\t\t)\n\t\t)\n\t)\n}\ntagPROPVARIANT|tagVARIANT|PROPVARIANT|VARIANT{\n\tpreview(\n\t\t#switch ($e.vt)\n\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\t\t;;\t\tBase Types\t\t;;\n\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\t\t#case 0 ( #(\"Empty\") )\t; VT_EMPTY\n\t\t#case 1 ( #(\"NULL\") )\t; VT_NULL\n\t\t#case 2 ( #(\"I2 = \", $e.iVal) ) ; VT_I2\n\t\t#case 3 ( #(\"I4 = \", $e.lVal) ) ; VT_I4\n\t\t#case 4 ( #(\"R4 = \", $e.fltVal) )\t\t; VT_R4\n\t\t#case 5 ( #(\"R8 = \", $e.dblVal) )\t\t; VT_R8\n\t\t#case 6 ( #(\"CY = \", $e.cyVal) )\t\t; VT_CY\n\t\t#case 7 ( #(\"DATE =  \", $e.date) )\t\t; VT_DATE\n\t\t#case 8 ( #(\"BSTR = \", $e.bstrVal) )\t; VT_BSTR\n\t\t#case 9 ( #(\"DISPATCH =  \", $e.pdispVal) )\t\t; VT_DISPATCH\n\t\t#case 10 ( #(\"ERROR =  \", $e.scode) )\t; VT_ERROR\n\t\t#case 0xB ( #(\"BOOL =  \", $e.boolVal) ) ; VT_BOOL\n\t\t#case 0xC ( #(\"VARIANT \") )\t\t; VT_VARIANT\n\t\t#case 0xD ( #(\"UNKNOWN =  \", $e.punkVal) )\t\t; VT_UNKOWN\n\t\t#case 0xE ( #(\"DECIMAL = \", $e.decVal) )\t\t; VT_DECIMAL\n\t\t#case 0x10 ( #(\"I1 =  \", $e.cVal) )\t\t; VT_I1\n\t\t#case 0x11 ( #(\"UI1 =  \", $e.bVal) )\t; VT_UI1\n\t\t#case 0x12 ( #(\"UI2 =  \", $e.uiVal) )\t; VT_UI2\n\t\t#case 0x13 ( #(\"UI4 =  \", $e.ulVal) )\t; VT_UI4\n\t\t#case 0x14 ( #(\"I8 =  \", *(__int64*)&$e.dblVal) )\t; VT_I8\n\t\t#case 0x15 ( #(\"UI8 =  \", *(unsigned __int64*)&$e.dblVal) )\t; VT_UI8\n\t\t#case 0x16 ( #(\"INT =  \", $e.intVal) )\t; VT_INT\n\t\t#case 0x17 ( #(\"UINT = \", $e.uintVal) ) ; VT_UINT\n\t\t#case 0x18 ( #(\"VOID \") )\t\t; VT_VOID\n\t\t#case 0x19 ( #(\"HRESULT \") )\t; VT_HRESULT\n\t\t#case 0x1A ( #(\"PTR \") )\t\t; VT_PTR\n\t\t#case 0x1B ( #(\"SAFEARRAY \") )\t; VT_SAFEARRAY\n\t\t#case 0x1C ( #(\"CARRAY \") )\t\t; VT_CARRAY\n\t\t#case 0x1D ( #(\"USERDEFINED \") )\t\t; VT_USERDEFINED\n\t\t#case 0x1E ( #(\"LPSTR =  \", $e.pszVal) )\t\t; VT_LPSTR\n\t\t#case 0x1F ( #(\"LPWSTR =  \", $e.pwszVal) )\t\t; VT_LPWSTR\n\t\t#case 0x24 ( #(\"RECORD\t\") )\t; VT_RECORD\n\t\t#case 0x26 ( #(\"UINT_PTR \") )\t; VT_UINT_PTR\n\t\t#case 0x40 ( #(\"FILETIME =\t\", $e.filetime) )\t; VT_FILETIME\n\t\t#case 0x42 ( #(\"STREAM =  \", $e.pStream) )\t\t; VT_STREAM\n\t\t#case 0x43 ( #(\"STORAGE = \", $e.pStorage) )\t\t; VT_STORAGE\n\t\t#case 0x44 ( #(\"STREAMED_OBJECT =  \", $e.pStream) )\t\t; VT_STREAMED_OBJECT\n\t\t#case 0x45 ( #(\"STORED_OBJECT =  \", $e.pStorage) )\t\t; VT_STORED_OBJECT\n\t\t#case 0x46 ( #(\"BLOB_OBJECT = \", $e.blob ) )\t; VT_BLOB_OBJECT\n\t\t#case 0x47 ( #(\"CF =  \", $e.pclipdata) )\t\t; VT_CF\n\t\t#case 0x48 ( #(\"CLSID = \", $e.puuid) )\t; VT_CLSID\n\t\t#case 0x49 ( #(\"VERSIONED_STREAM = \", $e.pVersionedStream) )\t; VT_VERSIONED_STREAM\n\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\t\t;;\t Vector types\t\t;;\n\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\t\t#case 0x1002 ( #(\"vector of I2 = \", $e.cai) )\t; VT_I2|VT_VECTOR\n\t\t#case 0x1003 ( #(\"vector of I4 = \", $e.cal) )\t; VT_I4|VT_VECTOR\n\t\t#case 0x1004 ( #(\"vector of R4 = \", $e.caflt) ) ; VT_R4|VT_VECTOR\n\t\t#case 0x1005 ( #(\"vector of R8 = \", $e.cadbl) ) ; VT_R8|VT_VECTOR\n\t\t#case 0x1010 ( #(\"vector of I1 =  \", $e.cac) )\t; VT_I1|VT_VECTOR\n\t\t#case 0x1011 ( #(\"vector of UI1 =  \", $e.caub) )\t\t; VT_UI1|VT_VECTOR\n\t\t#case 0x1012 ( #(\"vector of UI2 =  \", $e.caui) )\t\t; VT_UI2|VT_VECTOR\n\t\t#case 0x1013 ( #(\"vector of UI4 =  \", $e.caul) )\t\t; VT_UI4|VT_VECTOR\n\t\t#case 0x1014 ( #(\"vector of I8 =  \", $e.cah) )\t; VT_I8|VT_VECTOR\n\t\t#case 0x1015 ( #(\"vector of UI8 =  \", $e.cauh) )\t\t; VT_UI8|VT_VECTOR\n\t\t#case 0x101E ( #(\"vector of LPSTR =  \", $e.calpstr) )\t; VT_LPSTR|VT_VECTOR\n\t\t#case 0x101F ( #(\"vector of LPWSTR =  \", $e.calpwstr) ) ; VT_LPWSTR|VT_VECTOR\n\t\t#case 0x100C ( #(\"vector of VARIANT \", $e.capropvar) )\t; VT_VARIANT|VT_VECTOR\n\t\t#case 0x100B ( #(\"vector of BOOL =\t\", $e.cabool) )\t\t; VT_BOOL|VT_VECTOR\n\t\t#case 0x100A ( #(\"vector of ERROR =  \", $e.cascode) )\t; VT_ERROR|VT_VECTOR\n\t\t#case 0x1006 ( #(\"vector of CY = \", $e.cacy) )\t; VT_CY|VT_VECTOR\n\t\t#case 0x1007 ( #(\"vector of DATE =\t\", $e.cadate) )\t\t; VT_DATE|VT_VECTOR\n\t\t#case 0x1040 ( #(\"vector of FILETIME =\t\", $e.cafiletime) )\t\t; VT_FILETIME|VT_VECTOR\n\t\t#case 0x1048 ( #(\"vector of CLSID = \", $e.cauuid) )\t\t; VT_CLSID|VT_VECTOR\n\t\t#case 0x1047 ( #(\"vector of CF =  \", $e.caclipdata) )\t; VT_CF|VT_VECTOR\n\t\t#case 0x1008 ( #(\"vector of BSTR = \", $e.cabstr) )\t\t; VT_BSTR|VT_VECTOR\n\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\t\t;;\t Byref Types\t\t;;\n\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\t\t#case 0x4016 ( #(\"byref of INT =  \", $e.pintVal) )\t\t; VT_INT|VT_BYREF\n\t\t#case 0x4017 ( #(\"byref of UINT = \", $e.puintVal) )\t\t; VT_UINT|VT_BYREF\n\t\t#case 0x4002 ( #(\"byref of I2 = \", $e.piVal) )\t; VT_I2|VT_BYREF\n\t\t#case 0x4003 ( #(\"byref of I4 = \", $e.plVal) )\t; VT_I4|VT_BYREF\n\t\t#case 0x4004 ( #(\"byref of R4 = \", $e.pfltVal) )\t\t; VT_R4|VT_BYREF\n\t\t#case 0x4005 ( #(\"byref of R8 = \", $e.pdblVal) )\t\t; VT_R8|VT_BYREF\n\t\t#case 0x4010 ( #(\"byref of I1 =  \", $e.pcVal) ) ; VT_I1|VT_BYREF\n\t\t#case 0x4011 ( #(\"byref of UI1 =  \", $e.pbVal) )\t\t; VT_UI1|VT_BYREF\n\t\t#case 0x4012 ( #(\"byref of UI2 =  \", $e.puiVal) )\t\t; VT_UI2|VT_BYREF\n\t\t#case 0x4013 ( #(\"byref of UI4 =  \", $e.pulVal) )\t\t; VT_UI4|VT_BYREF\n\t\t#case 0x4014 ( #(\"byref of I8 =  \", (__int64*)$e.pdblVal) )\t\t; VT_I8|VT_BYREF\n\t\t#case 0x4015 ( #(\"byref of UI8 =  \", (unsigned __int64*)$e.pudblVal) )\t\t; VT_UI8|VT_BYREF\n\t\t#case 0x400C ( #(\"byref of VARIANT \", $e.pvarVal) )\t\t; VT_VARIANT|VT_BYREF\n\t\t#case 0x400B ( #(\"byref of BOOL =  \", $e.pboolVal) )\t; VT_BOOL|VT_BYREF\n\t\t#case 0x400A ( #(\"byref of ERROR =\t\", $e.pscode) )\t\t; VT_ERROR|VT_BYREF\n\t\t#case 0x4006 ( #(\"byref of CY = \", $e.pcyVal) ) ; VT_CY|VT_BYREF\n\t\t#case 0x4007 ( #(\"byref of DATE =  \", $e.pdate) )\t\t; VT_DATE|VT_BYREF\n\t\t#case 0x4008 ( #(\"byref of BSTR = \", $e.pbstrVal) )\t\t; VT_BSTR|VT_BYREF\n\t\t#case 0x400E ( #(\"byref of DECIMAL = \", $e.pdecVal) )\t; VT_DECIMAL|VT_BYREF\n\t\t#case 0x400D ( #(\"byref of UNKNOWN =  \", $e.ppunkVal) ) ; VT_UNKOWN|VT_BYREF\n\t\t#case 0x4009 ( #(\"byref of DISPATCH =  \", $e.ppdispVal) )\t\t; VT_DISPATCH|VT_BYREF\n\t\t#case 0x6000 ( #(\"byref of ARRAY =\t\", $e.pparray) )\t; VT_ARRAY|VT_BYREF\n\t\t#default\n\t\t(\n\t\t\t#if ($e.vt & 0x2000) ( $e.parray)\n\t\t\t#else ( #(\"Unknown vt type = \", $e.vt))\n\t\t)\n\t)\n\tchildren(\n\t\t#(\n\t\t\tvt: $e.vt,\n\t\t\t#switch ($e.vt)\n\t\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\t\t\t;;\t\tBase Types\t\t;;\n\t\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\t\t\t#case 0x2 ( #(I2  : $e.iVal) )\t; VT_I2\n\t\t\t#case 0x3 ( #(I4  : $e.lVal) )\t; VT_I4\n\t\t\t#case 0x4 ( #(R4  : $e.fltVal) )\t\t; VT_R4\n\t\t\t#case 0x5 ( #(R8  : $e.dblVal) )\t\t; VT_R8\n\t\t\t#case 0x6 ( #(CY  : $e.cyVal) ) ; VT_CY\n\t\t\t#case 0x7 ( #(DATE\t : $e.date) )\t\t; VT_DATE\n\t\t\t#case 0x8 ( #(BSTR\t: $e.bstrVal) )\t\t; VT_BSTR\n\t\t\t#case 0x9 ( #(DISPATCH\t : $e.pdispVal) )\t\t; VT_DISPATCH\n\t\t\t#case 0xA ( #(ERROR   : $e.scode) )\t\t; VT_ERROR\n\t\t\t#case 0xB ( #(BOOL\t : $e.boolVal) )\t; VT_BOOL\n\t\t\t#case 0xD ( #(UNKNOWN\t: $e.punkVal) ) ; VT_UNKOWN\n\t\t\t#case 0xE ( #(DECIMAL  : $e.decVal) )\t; VT_DECIMAL\n\t\t\t#case 0x10 ( #(I1\t: $e.cVal) )\t\t; VT_I1\n\t\t\t#case 0x11 ( #(UI1\t : $e.bVal) )\t\t; VT_UI1\n\t\t\t#case 0x12 ( #(UI2\t : $e.uiVal) )\t\t; VT_UI2\n\t\t\t#case 0x13 ( #(UI4\t : $e.ulVal) )\t\t; VT_UI4\n\t\t\t#case 0x14 ( #(I8\t: *(__int64*)&$e.dblVal) )\t\t; VT_I8\n\t\t\t#case 0x15 ( #(UI8\t : *(unsigned __int64*)&$e.dblVal) )\t\t; VT_UI8\n\t\t\t#case 0x16 ( #(INT\t : $e.intVal) )\t\t; VT_INT\n\t\t\t#case 0x17 ( #(UINT  : $e.uintVal) )\t; VT_UINT\n\t\t\t#case 0x1E ( #(LPSTR   : $e.pszVal) )\t; VT_LPSTR\n\t\t\t#case 0x1F ( #(LPWSTR\t: $e.pwszVal) ) ; VT_LPWSTR\n\t\t\t#case 0x40 ( #(FILETIME   : $e.filetime) )\t\t; VT_FILETIME\n\t\t\t#case 0x42 ( #(STREAM\t: $e.pStream) ) ; VT_STREAM\n\t\t\t#case 0x43 ( #(STORAGE\t: $e.pStorage) )\t\t; VT_STORAGE\n\t\t\t#case 0x44 ( #(STREAMED_OBJECT\t : $e.pStream) )\t\t; VT_STREAMED_OBJECT\n\t\t\t#case 0x45 ( #(STORED_OBJECT   : $e.pStorage) ) ; VT_STORED_OBJECT\n\t\t\t#case 0x46 ( #(BLOB_OBJECT\t: $e.blob ) )\t\t; VT_BLOB_OBJECT\n\t\t\t#case 0x47 ( #(CF\t: $e.pclipdata) )\t; VT_CF\n\t\t\t#case 0x48 ( #(CLSID  : $e.puuid) )\t\t; VT_CLSID\n\t\t\t#case 0x49 ( #(VERSIONED_STREAM  : $e.pVersionedStream) )\t\t; VT_VERSIONED_STREAM\n\t\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\t\t\t;;\t Vector types\t\t;;\n\t\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\t\t\t#case 0x1002 ( #(vector of I2  : $e.cai) )\t\t; VT_I2|VT_VECTOR\n\t\t\t#case 0x1003 ( #(vector of I4  : $e.cal) )\t\t; VT_I4|VT_VECTOR\n\t\t\t#case 0x1004 ( #(vector of R4  : $e.caflt) )\t; VT_R4|VT_VECTOR\n\t\t\t#case 0x1005 ( #(vector of R8  : $e.cadbl) )\t; VT_R8|VT_VECTOR\n\t\t\t#case 0x1010 ( #(vector of I1\t: $e.cac) )\t\t; VT_I1|VT_VECTOR\n\t\t\t#case 0x1011 ( #(vector of UI1\t : $e.caub) )\t; VT_UI1|VT_VECTOR\n\t\t\t#case 0x1012 ( #(vector of UI2\t : $e.caui) )\t; VT_UI2|VT_VECTOR\n\t\t\t#case 0x1013 ( #(vector of UI4\t : $e.caul) )\t; VT_UI4|VT_VECTOR\n\t\t\t#case 0x1014 ( #(vector of I8\t: $e.cah) )\t\t; VT_I8|VT_VECTOR\n\t\t\t#case 0x1015 ( #(vector of UI8\t : $e.cauh) )\t; VT_UI8|VT_VECTOR\n\t\t\t#case 0x101E ( #(vector of LPSTR   : $e.calpstr) )\t\t; VT_LPSTR|VT_VECTOR\n\t\t\t#case 0x101F ( #(vector of LPWSTR\t: $e.calpwstr) )\t; VT_LPWSTR|VT_VECTOR\n\t\t\t#case 0x100C ( #(vector of VARIANT : $e.capropvar) )\t; VT_VARIANT|VT_VECTOR\n\t\t\t#case 0x100B ( #(vector of BOOL   : $e.cabool) )\t\t; VT_BOOL|VT_VECTOR\n\t\t\t#case 0x100A ( #(vector of ERROR   : $e.cascode) )\t\t; VT_ERROR|VT_VECTOR\n\t\t\t#case 0x1006 ( #(vector of CY  : $e.cacy) )\t\t; VT_CY|VT_VECTOR\n\t\t\t#case 0x1007 ( #(vector of DATE   : $e.cadate) )\t\t; VT_DATE|VT_VECTOR\n\t\t\t#case 0x1040 ( #(vector of FILETIME   : $e.cafiletime) )\t\t; VT_FILETIME|VT_VECTOR\n\t\t\t#case 0x1048 ( #(vector of CLSID  : $e.cauuid) )\t\t; VT_CLSID|VT_VECTOR\n\t\t\t#case 0x1047 ( #(vector of CF\t: $e.caclipdata) )\t\t; VT_CF|VT_VECTOR\n\t\t\t#case 0x1008 ( #(vector of BSTR  : $e.cabstr) ) ; VT_BSTR|VT_VECTOR\n\t\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\t\t\t;;\t Byref Types\t\t;;\n\t\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\t\t\t#case 0x4016 ( #(byref of INT\t: $e.pintVal) ) ; VT_INT|VT_BYREF\n\t\t\t#case 0x4017 ( #(byref of UINT\t: $e.puintVal) )\t\t; VT_UINT|VT_BYREF\n\t\t\t#case 0x4002 ( #(byref of I2  : $e.piVal) )\t\t; VT_I2|VT_BYREF\n\t\t\t#case 0x4003 ( #(byref of I4  : $e.plVal) )\t\t; VT_I4|VT_BYREF\n\t\t\t#case 0x4004 ( #(byref of R4  : $e.pfltVal) )\t; VT_R4|VT_BYREF\n\t\t\t#case 0x4005 ( #(byref of R8  : $e.pdblVal) )\t; VT_R8|VT_BYREF\n\t\t\t#case 0x4010 ( #(byref of I1   : $e.pcVal) )\t; VT_I1|VT_BYREF\n\t\t\t#case 0x4011 ( #(byref of UI1\t: $e.pbVal) )\t; VT_UI1|VT_BYREF\n\t\t\t#case 0x4012 ( #(byref of UI2\t: $e.puiVal) )\t; VT_UI2|VT_BYREF\n\t\t\t#case 0x4013 ( #(byref of UI4\t: $e.pulVal) )\t; VT_UI4|VT_BYREF\n\t\t\t#case 0x4014 ( #(byref of I8\t: (__int64*)$e.pdblVal) )\t; VT_I8|VT_BYREF\n\t\t\t#case 0x4015 ( #(byref of UI8\t: (unsigned __int64*)$e.pdblVal) ) ; VT_UI8|VT_BYREF\n\t\t\t#case 0x400C ( #(byref of VARIANT : $e.pvarVal) )\t\t; VT_VARIANT|VT_BYREF\n\t\t\t#case 0x400B ( #(byref of BOOL\t : $e.pboolVal) )\t\t; VT_BOOL|VT_BYREF\n\t\t\t#case 0x400A ( #(byref of ERROR   : $e.pscode) )\t\t; VT_ERROR|VT_BYREF\n\t\t\t#case 0x4006 ( #(byref of CY  : $e.pcyVal) )\t; VT_CY|VT_BYREF\n\t\t\t#case 0x4007 ( #(byref of DATE\t : $e.pdate) )\t; VT_DATE|VT_BYREF\n\t\t\t#case 0x4008 ( #(byref of BSTR\t: $e.pbstrVal) )\t\t; VT_BSTR|VT_BYREF\n\t\t\t#case 0x400E ( #(byref of DECIMAL  : $e.pdecVal) )\t\t; VT_DECIMAL|VT_BYREF\n\t\t\t#case 0x400D ( #(byref of UNKNOWN\t: $e.ppunkVal) )\t; VT_UNKOWN|VT_BYREF\n\t\t\t#case 0x4009 ( #(byref of DISPATCH\t : $e.ppdispVal) )\t; VT_DISPATCH|VT_BYREF\n\t\t\t#case 0x6000 ( #(byref of ARRAY   : $e.pparray) )\t\t; VT_ARRAY|VT_BYREF\n\n\t\t\t; the following are either empty or invalid vt values for a variant\n\t\t\t; #case 0 ( #(Empty :) )\t\t; VT_EMPTY\n\t\t\t; #case 0x1 ( #(NULL :) )\t\t; VT_NULL\n\t\t\t; #case 0xC ( #(VARIANT :) )\t; VT_VARIANT\n\t\t\t; #case 0x18 ( #(VOID :) )\t\t; VT_VOID\n\t\t\t; #case 0x19 ( #(HRESULT :) )\t; VT_HRESULT\n\t\t\t; #case 0x1A ( #(PTR :) )\t\t; VT_PTR\n\t\t\t; #case 0x1B ( #(SAFEARRAY :) ) ; VT_SAFEARRAY\n\t\t\t; #case 0x1C ( #(CARRAY :) )\t; VT_CARRAY\n\t\t\t; #case 0x1D ( #(USERDEFINED :) )\t\t; VT_USERDEFINED\n\t\t\t; #case 0x24 ( #(RECORD  :) )\t; VT_RECORD\n\t\t\t; #case 0x26 ( #(UINT_PTR :) )\t; VT_UINT_PTR\n\t\t\t#default\n\t\t\t(\n\t\t\t\t#if ($e.vt & 0x2000 )\n\t\t\t\t\t( #(safearray: $e.parray))\n\t\t\t\t#else\n\t\t\t\t(\n\t\t\t\t\t#(\n\t\t\t\t\t\t[raw members]: [$e,!]\t; unformatted data members\n\t\t\t\t\t )\n\t\t\t\t )\n\t\t\t)\n\t\t\t#except\n\t\t\t(\n\t\t\t\t#(\n\t\t\t\t\t[raw members]: [$e,!]\t; unformatted data members\n\t\t\t\t )\n\t\t\t)\n\t\t)\n\t)\n}\n\n; Visualizers for data structures in namespace Concurrency\n;------------------------------------------------------------------------------\n;  Concurrency::message from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::message<*>{\n\tpreview (\n\t\t#(\n\t\t\t$e.payload\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(payload: $e.payload),\n\t\t\t#([msg_id]: $e._M_id)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::multi_link_registry from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::multi_link_registry<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._M_vector._M_index,\n\t\t\t\"](\",\n\t\t\t#array(\n\t\t\t\texpr: *($e._M_vector._M_array[$i]),\n\t\t\t\tsize: $e._M_vector._M_index\n\t\t\t),\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([size]: $e._M_vector._M_index),\n\t\t\t#array(\n\t\t\t\texpr: *($e._M_vector._M_array[$i]),\n\t\t\t\tsize: $e._M_vector._M_index\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::details::_Queue from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::details::_Queue<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._M_count,\n\t\t\t\"](\",\n\t\t\t#list(\n\t\t\t\thead: $e._M_pHead,\n\t\t\t\tnext: _M_pNext,\n\t\t\t\tsize: _M_count\n\t\t\t),\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([size]: $e._M_count),\n\t\t\t#list(\n\t\t\t\thead: $e._M_pHead,\n\t\t\t\tnext: _M_pNext,\n\t\t\t\tsize: _M_count\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::unbounded_buffer from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::unbounded_buffer<*>{\n\tpreview (\n\t\t#(\n\t\t\t$e._M_messageBuffer\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(unprocessed_messages: $e._M_messageProcessor._M_queuedMessages._M_queue),\n\t\t\t#(messages: $e._M_messageBuffer),\n\t\t\t#(message_filter: *($e._M_pFilter)),\n\t\t\t#(linked_sources: $e._M_connectedSources._M_links),\n\t\t\t#(linked_targets: $e._M_connectedTargets),\n\t\t\t#(reserving_target: *($e._M_pReservedFor)),\n\t\t\t#(Scheduler: *($e._M_messageProcessor._M_pScheduler)),\n\t\t\t#(ScheduleGroup: *($e._M_messageProcessor._M_pScheduleGroup))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::overwrite_buffer from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::overwrite_buffer<*>{\n\tpreview (\n\t\t#(\n\t\t\t$e._M_pMessage\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(value: *($e._M_pMessage)),\n\t\t\t#(unprocessed_messages: $e._M_messageProcessor._M_queuedMessages._M_queue),\n\t\t\t#(message_filter: *($e._M_pFilter)),\n\t\t\t#(linked_sources: $e._M_connectedSources._M_links),\n\t\t\t#(linked_targets: $e._M_connectedTargets),\n\t\t\t#(reserving_target: *($e._M_pReservedFor)),\n\t\t\t#(reserved_message: *($e._M_pReservedMessage)),\n\t\t\t#(Scheduler: *($e._M_messageProcessor._M_pScheduler)),\n\t\t\t#(ScheduleGroup: *($e._M_messageProcessor._M_pScheduleGroup))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::single_assignment from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::single_assignment<*>{\n\tpreview (\n\t\t#(\n\t\t\t$e._M_pMessage\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(value: *($e._M_pMessage)),\n\t\t\t#(unprocessed_messages: $e._M_messageProcessor._M_queuedMessages._M_queue),\n\t\t\t#(message_filter: *($e._M_pFilter)),\n\t\t\t#(linked_sources: $e._M_connectedSources._M_links),\n\t\t\t#(linked_targets: $e._M_connectedTargets),\n\t\t\t#(reserving_target: *($e._M_pReservedFor)),\n\t\t\t#(Scheduler: *($e._M_messageProcessor._M_pScheduler)),\n\t\t\t#(ScheduleGroup: *($e._M_messageProcessor._M_pScheduleGroup))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::call from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::call<*>{\n\tpreview (\n\t\t#(\n\t\t\t$e._M_pFunc\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(call_method: $e._M_pFunc),\n\t\t\t#(unprocessed_messages: $e._M_messageProcessor._M_queuedMessages._M_queue),\n\t\t\t#(message_filter: *($e._M_pFilter)),\n\t\t\t#(linked_sources: $e._M_connectedSources._M_links),\n\t\t\t#(Scheduler: *($e._M_messageProcessor._M_pScheduler)),\n\t\t\t#(ScheduleGroup: *($e._M_messageProcessor._M_pScheduleGroup))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::transformer from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::transformer<*>{\n\tpreview (\n\t\t#(\n\t\t\t$e._M_pFunc\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(transform_method: $e._M_pFunc),\n\t\t\t#(unprocessed_messages: $e._M_messageProcessor._M_queuedMessages._M_queue),\n\t\t\t#(messages: $e._M_messageBuffer),\n\t\t\t#(message_filter: *($e._M_pFilter)),\n\t\t\t#(linked_sources: $e._M_connectedSources._M_links),\n\t\t\t#(linked_target: *($e._M_connectedTargets._M_connectedLink)),\n\t\t\t#(reserving_target: *($e._M_pReservedFor)),\n\t\t\t#(Scheduler: *($e._M_messageProcessor._M_pScheduler)),\n\t\t\t#(ScheduleGroup: *($e._M_messageProcessor._M_pScheduleGroup))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::choice from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::choice<*>{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t#if ($e._M_pSingleAssignment->_M_fIsInitialized) (\"initialized\")\n\t\t\t#else (\"not_initialized\"),\n\t\t\t\"] \",\n\t\t\t$e._M_sourceTuple\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([input_count]: $e._M_pSingleAssignment->_M_connectedSources._M_links._M_vector._M_index),\n\t\t\t#(index: $e._M_pSingleAssignment->_M_pMessage->payload),\n\t\t\t#(source_tuple: $e._M_sourceTuple),\n\t\t\t#(linked_sources: $e._M_pSingleAssignment->_M_connectedSources._M_links),\n\t\t\t#(linked_targets: $e._M_pSingleAssignment->_M_connectedTargets),\n\t\t\t#(reserving_target: *($e._M_pSingleAssignment->_M_pReservedFor)),\n\t\t\t#(Scheduler: *($e._M_pScheduler)),\n\t\t\t#(ScheduleGroup: *($e._M_pScheduleGroup)),\n\t\t\t#([raw _M_pSourceChoices] : $e._M_pSourceChoices)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::join<*,*>::_MessageArray from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::join<*,*>::_MessageArray{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._M_count,\n\t\t\t\"](\",\n\t\t\t#array(\n\t\t\t\texpr: *(((Concurrency::message<$T1>**)$e._M_messages)[$i]),\n\t\t\t\tsize: $e._M_count\n\t\t\t),\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([size]: $e._M_count),\n\t\t\t#array(\n\t\t\t\texpr: *(((Concurrency::message<$T1>**)$e._M_messages)[$i]),\n\t\t\t\tsize: $e._M_count\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::join<*,*>::_SavedMessageIdArray from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::join<*,*>::_SavedMessageIdArray{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._M_count,\n\t\t\t\"](\",\n\t\t\t#array(\n\t\t\t\texpr: ((int*)$e._M_savedIds)[$i],\n\t\t\t\tsize: $e._M_count\n\t\t\t),\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([size]: $e._M_count),\n\t\t\t#array(\n\t\t\t\texpr: ((int*)$e._M_savedIds)[$i],\n\t\t\t\tsize: $e._M_count\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::join from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::join<*,*>{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._M_messageArray._M_count - $e._M_messagesRemaining,\n\t\t\t\"/\",\n\t\t\t$e._M_messageArray._M_count,\n\t\t\t\"](\",\n\t\t\t#array(\n\t\t\t\texpr: *($e._M_connectedSources._M_links._M_vector._M_array[$i]),\n\t\t\t\tsize: $e._M_connectedSources._M_links._M_vector._M_index\n\t\t\t),\n\t\t\t\")\"\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([join_type]: (Concurrency::join_type)$T2),\n\t\t\t#([offer_count]: $e._M_messageArray._M_count - $e._M_messagesRemaining),\n\t\t\t#(offer_IDs: $e._M_savedMessageIdArray),\n\t\t\t#([input_count]: $e._M_messageArray._M_count),\n\t\t\t#(input_values: $e._M_messageArray),\n\t\t\t#(messages: $e._M_messageBuffer),\n\t\t\t#(message_filter: *($e._M_pFilter)),\n\t\t\t#(linked_sources: $e._M_connectedSources._M_links),\n\t\t\t#(linked_target: $e._M_connectedTargets._M_connectedLink),\n\t\t\t#(reserving_target: *($e._M_pReservedFor)),\n\t\t\t#(Scheduler: *($e._M_messageProcessor._M_pScheduler)),\n\t\t\t#(ScheduleGroup: *($e._M_messageProcessor._M_pScheduleGroup))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::multitype_join from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::multitype_join<*,*>{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._M_pJoinNode->_M_connectedSources._M_links._M_vector._M_index - $e._M_pJoinNode->_M_counter,\n\t\t\t\"/\",\n\t\t\t$e._M_pJoinNode->_M_connectedSources._M_links._M_vector._M_index,\n\t\t\t\"]\",\n\t\t\t$e._M_sourceTuple\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([join_type]: (Concurrency::join_type)$T2),\n\t\t\t#([offer_count]: $e._M_pJoinNode->_M_connectedSources._M_links._M_vector._M_index - $e._M_pJoinNode->_M_counter),\n\t\t\t#([input_count]: $e._M_pJoinNode->_M_connectedSources._M_links._M_vector._M_index),\n\t\t\t#(source_tuple: $e._M_sourceTuple),\n\t\t\t#(messages: $e._M_pJoinNode->_M_messageBuffer),\n\t\t\t#(linked_sources: $e._M_pJoinNode->_M_connectedSources._M_links),\n\t\t\t#(linked_target: $e._M_pJoinNode->_M_connectedTargets._M_connectedLink),\n\t\t\t#(reserving_target: *($e._M_pJoinNode->_M_pReservedFor)),\n\t\t\t#(Scheduler: *($e._M_pJoinNode->_M_messageProcessor._M_pScheduler)),\n\t\t\t#(ScheduleGroup: *($e._M_pJoinNode->_M_messageProcessor._M_pScheduleGroup)),\n\t\t\t#([raw _M_pSourceJoins] : $e._M_pSourceJoins)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::timer from <agents.h>\n;------------------------------------------------------------------------------\nConcurrency::timer<*>{\n\tpreview (\n\t\t#(\n\t\t\t$e._M_state\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(state: $e._M_state),\n\t\t\t#(value: $e._M_value),\n\t\t\t#(repeating: $e._M_fRepeating),\n\t\t\t#(interval_ms: $e._M_ms),\n\t\t\t#(linked_target: *($e._M_connectedTargets._M_connectedLink)),\n\t\t\t#(reserving_target: *($e._M_pReservedFor)),\n\t\t\t#(Scheduler: *($e._M_messageProcessor._M_pScheduler)),\n\t\t\t#(ScheduleGroup: *($e._M_messageProcessor._M_pScheduleGroup))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::details::SchedulerBase from <SchedulerBase.h>\n;  Concurrency::details::ThreadScheduler from <ThreadScheduler.h>\n;  Concurrency::details::UMSThreadScheduler from <UMSThreadScheduler.h>\n;------------------------------------------------------------------------------\nConcurrency::details::SchedulerBase|Concurrency::details::ThreadScheduler|Concurrency::details::UMSThreadScheduler{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e.m_id,\n\t\t\t\"] \",\n\t\t\t#if ($e.m_schedulerKind == 0) (\"ThreadScheduler\")\n\t\t\t#else (\"UmsScheduler\"),\n\t\t\t#if ($e.m_id == $e.s_pDefaultScheduler->m_id) (\", default\")\n\t\t\t#else (\"\")\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(ID: $e.m_id),\n\t\t\t#(SchedulerPolicy: $e.m_policy),\n\t\t\t#(VirtualProcessorCount: $e.m_virtualProcessorCount),\n\t\t\t#(ReferenceCount: $e.m_refCount),\n\t\t\t#([isDefaultScheduler]: $e.m_id == $e.s_pDefaultScheduler->m_id)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::details::ScheduleGroupBase from <ScheduleGroupBase.h>\n;  Concurrency::details::CacheLocalScheduleGroup from <CacheLocalScheduleGroup.h>\n;  Concurrency::details::FairScheduleGroup from <FairScheduleGroup.h>\n;------------------------------------------------------------------------------\nConcurrency::details::ScheduleGroupBase|Concurrency::details::CacheLocalScheduleGroup|Concurrency::details::FairScheduleGroup{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e.m_id,\n\t\t\t\"]\",\n\t\t\t#if ($e.m_kind & 4) (\" AnonymousScheduleGroup\")\n\t\t\t#else (\"\")\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(ID: $e.m_id),\n\t\t\t#(Scheduler: *($e.m_pScheduler))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::details::ContextBase from <ContextBase.h>\n;  Concurrency::details::InternalContextBase from <InternalContextBase.h>\n;  Concurrency::details::ThreadInternalContext from <ThreadInternalContext.h>\n;  Concurrency::details::UMSThreadInternalContext from <UMSThreadInternalContext.h>\n;------------------------------------------------------------------------------\nConcurrency::details::ContextBase|Concurrency::details::InternalContextBase|Concurrency::details::ThreadInternalContext|Concurrency::details::UMSThreadInternalContext{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e.m_threadId,\n\t\t\t\"] \",\n\t\t\t#if ($e.m_blockedState == 0) (\"not_concrt_blocked\")\n\t\t\t#elif ($e.m_blockedState == 1) (\"concrt_blocked\")\n\t\t\t#elif ($e.m_blockedState == 2) (\"ums_sync_blocked\")\n\t\t\t#elif ($e.m_blockedState == 4) (\"ums_async_blocked\")\n\t\t\t#else (\"\")\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(ID: $e.m_id),\n\t\t\t#(ThreadID: $e.m_threadId),\n\t\t\t#(Scheduler: *($e.m_pScheduler)),\n\t\t\t#(ScheduleGroup: *($e.m_pGroup))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::details::ExternalContextBase from <ExternalContextBase.h>\n;------------------------------------------------------------------------------\nConcurrency::details::ExternalContextBase{\n\tpreview (\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e.m_threadId,\n\t\t\t\"] \",\n\t\t\t#if ($e.m_contextSwitchingFence == 1) (\"concrt_blocked\")\n\t\t\t#else (\"not_concrt_blocked\")\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(ID: $e.m_id),\n\t\t\t#(ThreadID: $e.m_threadId),\n\t\t\t#(Scheduler: *($e.m_pScheduler)),\n\t\t\t#(ScheduleGroup: *($e.m_pGroup))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::SchedulerPolicy from <concrt.h>\n;------------------------------------------------------------------------------\nConcurrency::SchedulerPolicy{\n\tpreview (\n\t\t#(\n\t\t\t$e._M_pPolicyBag->_M_values._M_specificValues._M_schedulerKind,\n\t\t\t\", Min=\",\n\t\t\t$e._M_pPolicyBag->_M_values._M_specificValues._M_minConcurrency,\n\t\t\t\", Max=\",\n\t\t\t$e._M_pPolicyBag->_M_values._M_specificValues._M_maxConcurrency\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(SchedulerKind: $e._M_pPolicyBag->_M_values._M_specificValues._M_schedulerKind),\n\t\t\t#(MinConcurrency: $e._M_pPolicyBag->_M_values._M_specificValues._M_minConcurrency),\n\t\t\t#(MaxConcurrency: $e._M_pPolicyBag->_M_values._M_specificValues._M_maxConcurrency),\n\t\t\t#(TargetOversubscriptionFactor: $e._M_pPolicyBag->_M_values._M_specificValues._M_targetOversubscriptionFactor),\n\t\t\t#(LocalContextCacheSize: $e._M_pPolicyBag->_M_values._M_specificValues._M_localContextCacheSize),\n\t\t\t#(ContextStackSize: $e._M_pPolicyBag->_M_values._M_specificValues._M_contextStackSize),\n\t\t\t#(ContextPriority: $e._M_pPolicyBag->_M_values._M_specificValues._M_contextPriority),\n\t\t\t#(SchedulingProtocol: $e._M_pPolicyBag->_M_values._M_specificValues._M_schedulingProtocol),\n\t\t\t#(DynamicProgressFeedback: $e._M_pPolicyBag->_M_values._M_specificValues._M_dynamicProgressFeedback)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::event from <concrt.h>\n;------------------------------------------------------------------------------\nConcurrency::event{\n\tpreview (\n\t\t#(\n\t\t\t#if ($e._M_pWaitChain == 1) (\"set\")\n\t\t\t#else (\"not_set\")\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([is_set]: ($e._M_pWaitChain == 1)),\n\t\t\t#([has_waiters]: (($e._M_pWaitChain != 0) && ($e._M_pWaitChain != 1)))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::critical_section from <concrt.h>\n;------------------------------------------------------------------------------\nConcurrency::critical_section{\n\tpreview (\n\t\t#(\n\t\t\t#if ($e._M_pHead != 0) (\"locked\")\n\t\t\t#else (\"not_locked\")\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([is_locked]: ($e._M_pHead != 0)),\n\t\t\t#(OwningContext: *((Concurrency::Context*)($e._M_activeNode[0])))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::critical_section::scoped_lock from <concrt.h>\n;------------------------------------------------------------------------------\nConcurrency::critical_section::scoped_lock{\n\tpreview (\n\t\t#(\n\t\t\t$e._M_critical_section\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\tCriticalSection: $e._M_critical_section\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::reader_writer_lock from <concrt.h>\n;------------------------------------------------------------------------------\nConcurrency::reader_writer_lock{\n\tpreview (\n\t\t#(\n\t\t\t#if (($e._M_lockState < 8) && ($e._M_lockState & 2)) (\"held_by_writer\")\n\t\t\t#elif ($e._M_lockState >= 8) (\n\t\t\t\t#(\n\t\t\t\t\t\"held_by_reader(s) [\",\n\t\t\t\t\t($e._M_lockState / 8),\n\t\t\t\t\t\"]\"\n\t\t\t\t)\n\t\t\t)\n\t\t\t#else (\"not_held\")\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([is_reader_lock_held]: ($e._M_lockState >= 8)),\n\t\t\t#([num_reader_lock_holders]: ($e._M_lockState / 8)),\n\t\t\t#([is_writer_lock_held]: ($e._M_lockState < 8) && ($e._M_lockState & 2)),\n\t\t\t#(OwningWriterContext: *((Concurrency::Context*)($e._M_activeWriter[0])))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::reader_writer_lock::scoped_lock from <concrt.h>\n;  Concurrency::reader_writer_lock::scoped_lock_read from <concrt.h>\n;------------------------------------------------------------------------------\nConcurrency::reader_writer_lock::scoped_lock|Concurrency::reader_writer_lock::scoped_lock_read{\n\tpreview (\n\t\t#(\n\t\t\t$e._M_reader_writer_lock\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\tReaderWriterLock: $e._M_reader_writer_lock\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::details::_TaskCollectionBase from <concrt.h>\n;------------------------------------------------------------------------------\nConcurrency::details::_TaskCollectionBase{\n\tpreview (\n\t\t#(\n\t\t\t#if ((((int)$e._M_pException & ~0x3) != 0) && (((int)$e._M_pException & ~0x3) != 0xC)) (\"exception\")\n\t\t\t#else (\"no_exception\")\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([has_exception]: (((int)$e._M_pException & ~0x3) != 0) && (((int)$e._M_pException & ~0x3) != 0xC)),\n\t\t\t#(CreatingContext: *((Concurrency::Context*)$e._M_pOwningContext))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::task_group from <ppl.h>\n;  Concurrency::structured_task_group from <ppl.h>\n;------------------------------------------------------------------------------\nConcurrency::task_group|Concurrency::structured_task_group{\n\tpreview (\n\t\t#(\n\t\t\t#if ((((int)$e._M_task_collection._M_pException & ~0x3) != 0) && (((int)$e._M_task_collection._M_pException & ~0x3) != 0xC)) (\"exception\")\n\t\t\t#else (\"no_exception\")\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#([has_exception]: (((int)$e._M_task_collection._M_pException & ~0x3) != 0) && (((int)$e._M_task_collection._M_pException & ~0x3) != 0xC)),\n\t\t\t#(CreatingContext: *((Concurrency::Context*)$e._M_task_collection._M_pOwningContext))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::task_handle from <ppl.h>\n;------------------------------------------------------------------------------\nConcurrency::task_handle<*>{\n\tpreview (\n\t\t#(\n\t\t\t$e._M_function\n\t\t)\n\t)\n\n\tchildren (\n\t\t#(\n\t\t\t#(Function: $e._M_function),\n\t\t\t#(RuntimeOwnsLifetime: $e._M_fRuntimeOwnsLifetime),\n\t\t\t#(TaskCollection: *($e._M_pTaskCollection))\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::combinable from <ppl.h>\n;------------------------------------------------------------------------------\nConcurrency::combinable<*>{\n\tpreview(\n\t\t#(\n\t\t\t\"(\",\n\t\t\t#array(\n\t\t\t\texpr: *($e._M_buckets[$i]),\n\t\t\t\tsize: $e._M_size\n\t\t\t) : #list(\n\t\t\t\thead: $e,\n\t\t\t\tnext: _M_chain\n\t\t\t) : $e._M_value,\n\t\t\t\")\"\n\t\t)\n\t)\n\tchildren(\n\t\t#(\n\t\t\t#array(\n\t\t\t\texpr: *($e._M_buckets[$i]),\n\t\t\t\tsize: $e._M_size\n\t\t\t) : #list(\n\t\t\t\thead: $e,\n\t\t\t\tnext: _M_chain\n\t\t\t) : $e._M_value,\n\t\t\t#(InitFunction : $e._M_fnInitialize)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::concurrent_vector from <concurrent_vector.h>\n;------------------------------------------------------------------------------\nConcurrency::concurrent_vector<*,*>{\n\tpreview(\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._My_early_size._M_value,\n\t\t\t\"](\",\n\t\t\t#array (\n\t\t\t\texpr: #(\n\t\t\t\t\t\t #if (($i >> 1) == 0) ((($T1*)$e._My_segment._M_value[0]._My_array)[$i])\n\t\t\t\t\t\t #else ((($T1*)$e._My_segment._M_value[__log2($i)]._My_array)[$i - (0x1 << __log2($i))])\n\t\t\t\t\t   ),\n\t\t\t\tsize: $e._My_early_size._M_value\n\t\t\t),\n\t\t\t\")\"\n\t\t)\n\t)\n\tchildren(\n\t\t#(\n\t\t\t[size] : $e._My_early_size._M_value,\n\t\t\t#array (\n\t\t\t\texpr: #(\n\t\t\t\t\t\t #if (($i >> 1) == 0) ((($T1*)$e._My_segment._M_value[0]._My_array)[$i])\n\t\t\t\t\t\t #else ((($T1*)$e._My_segment._M_value[__log2($i)]._My_array)[$i - (0x1 << __log2($i))])\n\t\t\t\t\t   ),\n\t\t\t\tsize: $e._My_early_size._M_value\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::details::_Vector_iterator from <concurrent_vector.h>\n;------------------------------------------------------------------------------\nConcurrency::details::_Vector_iterator<Concurrency::concurrent_vector<*,*>,*>{\n\tpreview(\n\t\t#(\n\t\t\t#if (($e._My_index >> 1) == 0) ((($T1*)$e._My_vector->_My_segment._M_value[0]._My_array)[$e._My_index])\n\t\t\t#else ((($T1*)$e._My_vector->_My_segment._M_value[__log2($e._My_index)]._My_array)[$e._My_index - (0x1 << __log2($e._My_index))])\n\t\t)\n\t)\n\tchildren(\n\t\t#(\n\t\t\t[ptr]: #if (($e._My_index >> 1) == 0) (&((($T1*)$e._My_vector->_My_segment._M_value[0]._My_array)[$e._My_index]))\n\t\t\t\t   #else (&((($T1*)$e._My_vector->_My_segment._M_value[__log2($e._My_index)]._My_array)[$e._My_index - (0x1 << __log2($e._My_index))]))\n\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::concurrent_queue from <concurrent_queue.h>\n;------------------------------------------------------------------------------\nConcurrency::concurrent_queue<*,*>{\n\tpreview\n\t(\n\t\t#(\n\t\t\t\"[\",\n\t\t\t$e._My_rep->_Tail_counter._M_value - $e._My_rep->_Head_counter._M_value,\n\t\t\t\"](\",\n\t\t\t#array\n\t\t\t(\n\t\t\t\texpr : #if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 0) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 1) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 2) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 3) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 4) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 5) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 6) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 7) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 8) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 9) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 10) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 11) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 12) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 13) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 14) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 15) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 16) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 17) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 18) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 19) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])))))))))))))))))))),\n\t\t\t\tsize : #if ($e._My_rep->_Tail_counter._M_value-$e._My_rep->_Head_counter._M_value < 20*8*$e._Items_per_page) ($e._My_rep->_Tail_counter._M_value-$e._My_rep->_Head_counter._M_value)\n\t\t\t\t\t   #else (20*8*$e._Items_per_page)\n\t\t\t),\n\t\t\t\")\"\n\t\t)\n\t)\n\tchildren\n\t(\n\t\t#(\n\t\t\t#([unsafe_size]: $e._My_rep->_Tail_counter._M_value-$e._My_rep->_Head_counter._M_value),\n\t\t\t#array\n\t\t\t(\n\t\t\t\texpr : #if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 0) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 1) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 2) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 3) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 4) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 5) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 6) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 7) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 8) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 9) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 10) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 11) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 12) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 13) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 14) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 15) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 16) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 17) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 18) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else (#if (($i+($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)))/(8*$e._Items_per_page)-($e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>(8*($e._Items_per_page-1)))*($i%8+$e._My_rep->_Head_counter._M_value%(8*$e._Items_per_page)>=(8*$e._Items_per_page)) == 19) ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])\n\t\t\t\t\t   #else ((($T1*)(($e._My_rep->_Array[(($i+$e._My_rep->_Head_counter._M_value)*3%8)]._Head_page._M_value->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next->_Next) + 1))[(($i+$e._My_rep->_Head_counter._M_value)&-8)/8&$e._Items_per_page-1])))))))))))))))))))),\n\t\t\t\tsize : #if ($e._My_rep->_Tail_counter._M_value-$e._My_rep->_Head_counter._M_value < 20*8*$e._Items_per_page) ($e._My_rep->_Tail_counter._M_value-$e._My_rep->_Head_counter._M_value)\n\t\t\t\t\t   #else (20*8*$e._Items_per_page)\n\t\t\t)\n\t\t)\n\t)\n}\n\n;------------------------------------------------------------------------------\n;  Concurrency::details::_Concurrent_queue_iterator from <concurrent_queue.h>\n;------------------------------------------------------------------------------\nConcurrency::details::_Concurrent_queue_iterator<Concurrency::concurrent_queue<*,*>,*>{\n\tpreview(\n\t\t#(\n\t\t\t*(($T1*)$e._My_item)\n\t\t)\n\t)\n\tchildren(\n\t\t#(\n\t\t\t[ptr]: (($T1*)$e._My_item)\n\n\t\t)\n\t)\n}\n\n; This section lets you define your own errors for the HRESULT display.\n; You need to list the error code in unsigned decimal, followed by the message.\n; Changes will take effect the next time you redisplay the variable.\n\n[hresult]\n;1234=my custom error code\n\n",
			"file": "/C/Program Files (x86)/Microsoft Visual Studio 14.0/Common7/Packages/Debugger/autoexp.dat",
			"file_size": 120100,
			"file_write_time": 130872040460000000,
			"settings":
			{
				"buffer_size": 123064,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "Source/UnrealFusion/FusionPlant.h",
			"settings":
			{
				"buffer_size": 7127,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Source/UnrealFusion/Fusion/Correlator.cpp",
			"settings":
			{
				"buffer_size": 7427,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "Source/UnrealFusion/Fusion/Utilities/CommonMath.h",
			"settings":
			{
				"buffer_size": 6942,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Source/UnrealFusion/Fusion/ArticulatedModel.h",
			"settings":
			{
				"buffer_size": 4922,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Users/User/Code/UnrealFusion",
		"/C/Users/User/Code/UnrealFusion/FusionTesting",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion"
	],
	"file_history":
	[
		"/C/Users/User/autoexp_backup.dat",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/CorrelationProcedures.cpp",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/FusionTypes.cpp",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/Utilities/CorrelationUtilities.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/Calibration.cpp",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/FusionTypes.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/Calibration.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/Core.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/FusionGraph.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/FusionGraph.cpp",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Eigen/src/Cholesky/LDLT.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/DataAnalysisModule.h",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/DataAnalysisModule.cpp",
		"/C/Users/User/Code/UnrealFusion/Source/UnrealFusion/Fusion/Correlator.h",
		"/C/Users/User/Code/UnrealFusion/.gitignore",
		"/C/Users/User/Code/UnrealFusion/README.md",
		"/C/Users/User/Code/DeepLearningRenderer/scripts/addons/blender/DeepLearningRenderer/geometry.py",
		"/C/Users/User/Code/DeepLearningRenderer/scripts/addons/blender/DeepLearningRenderer/ui.py",
		"/C/Program Files/Blender Foundation/Blender/2.78/scripts/addons/DeepLearningRenderer/ui.py",
		"/C/Users/User/Code/DeepLearningRenderer/scripts/setup_addon.bat",
		"/C/Users/User/Code/DeepLearningRenderer/scripts/setup_addons.py",
		"/E/Unity/VRGame/Assets/Scripts/CrazyCube.cs",
		"/E/Unity/VRGame/Assets/Scripts/Notes.txt",
		"/E/Unity/VRGame/Assets/Scripts/Grabbing.cs"
	],
	"find":
	{
		"height": 50.0
	},
	"find_in_files":
	{
		"height": 138.0,
		"where_history":
		[
			"C:\\Users\\User\\Code\\UnrealFusion\\Source\\UnrealFusion\\Fusion",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"[Visualizer",
			"isAmbiguous",
			"isSt",
			"source_out",
			"TODO",
			"m.first",
			"m.second",
			"std::vector<std::pair<Measurement::Ptr, NodeDescriptor>>",
			"Measurement",
			"checkChanges",
			"TODO",
			"factor",
			"movementsPerPoint",
			"i",
			"x0",
			"1.0",
			"hdriLocation",
			"x",
			"setWorldHDRIMap",
			"Texture",
			"bpy.context.",
			"v",
			"vt",
			"..",
			"\"touch.d",
			"\"touch",
			"\")",
			"state",
			"\",\"",
			",",
			"InputFilter",
			"Touch",
			"Button",
			"thumb_stick",
			"touch",
			"InputFilter",
			",",
			";"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 4,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "Source/UnrealFusion/Fusion/Core.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4109,
						"regions":
						{
						},
						"selection":
						[
							[
								2850,
								2850
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 656.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "Source/UnrealFusion/FusionPlant.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14041,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2996.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "Source/UnrealFusion/Fusion/Correlator.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5571,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1031.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "FusionTesting/CalibrationTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2591,
						"regions":
						{
						},
						"selection":
						[
							[
								2545,
								2545
							]
						],
						"settings":
						{
							"history_list_is_closing": true,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/C/Program Files (x86)/Microsoft Visual Studio 14.0/Common7/Packages/Debugger/autoexp.dat",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 123064,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								123064
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1020.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "Source/UnrealFusion/FusionPlant.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7127,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1277.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				}
			]
		},
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 6,
					"file": "Source/UnrealFusion/Fusion/Correlator.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7427,
						"regions":
						{
						},
						"selection":
						[
							[
								2715,
								2715
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 1353.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "Source/UnrealFusion/Fusion/Utilities/CommonMath.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6942,
						"regions":
						{
						},
						"selection":
						[
							[
								6464,
								6464
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 3120.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 8,
					"file": "Source/UnrealFusion/Fusion/ArticulatedModel.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4922,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"auto_name": "",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 28.0
	},
	"input":
	{
		"height": 43.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			],
			[
				2,
				0,
				3,
				1
			]
		],
		"cols":
		[
			0.0,
			0.39310254163,
			0.69334360393,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 560.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "unrealfusion.sublime-project",
	"replace":
	{
		"height": 58.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"commonma",
				"Source\\UnrealFusion\\Fusion\\Utilities\\CommonMath.h"
			],
			[
				"fusiontypes",
				"Source\\UnrealFusion\\Fusion\\FusionTypes.h"
			],
			[
				"gun",
				"Assets\\Scripts\\Gun.cs"
			],
			[
				"cra",
				"Assets\\Scripts\\CrazyCube.cs"
			],
			[
				"hand",
				"Assets\\Scripts\\Hand.cs"
			],
			[
				"inp",
				"Assets\\Scripts\\ObjectInput.cs"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 417.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
